/*
 * File: app/model/compassData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.model.compassData', {
    extend: 'Ext.data.Model',

    config: {
        fields: [
            {
                name: 'bearing',
                type: 'float'
            },
            {
                name: 'date',
                type: 'date'
            }
        ],
        proxy: {
            type: 'localstorage',
            id: 'compassData'
        }
    }
});
/*
 * File: app/model/gpsData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.model.gpsData', {
    extend: 'Ext.data.Model',

    config: {
        fields: [
            {
                name: 'x',
                type: 'float'
            },
            {
                name: 'y',
                type: 'float'
            },
            {
                name: 'date',
                type: 'date'
            }
        ],
        proxy: {
            type: 'localstorage',
            id: 'gpsData'
        }
    }
});
/*
 * File: app/model/conf.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.model.conf', {
    extend: 'Ext.data.Model',

    config: {
        idProperty: 'conf',
        fields: [
            {
                name: 'obj'
            },
            {
                name: 'date',
                type: 'date'
            },
            {
                name: 'autoFollow',
                type: 'boolean'
            }
        ],
        proxy: {
            type: 'localstorage',
            id: 'confData'
        }
    }
});
/*
 * File: app/model/landingLine.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.model.landingLine', {
    extend: 'Ext.data.Model',

    config: {
        idProperty: 'landingLine',
        fields: [
            {
                name: 'startLat',
                type: 'float'
            },
            {
                name: 'startLng',
                type: 'float'
            },
            {
                name: 'endLat',
                type: 'float'
            },
            {
                name: 'endLng',
                type: 'float'
            },
            {
                name: 'title',
                type: 'string'
            },
            {
                name: 'date',
                type: 'date'
            }
        ],
        proxy: {
            type: 'localstorage',
            id: 'landingLine'
        }
    }
});
/*
 * File: app/model/poi.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.model.poi', {
    extend: 'Ext.data.Model',

    config: {
        fields: [
            {
                name: 'lng',
                type: 'float'
            },
            {
                name: 'lat',
                type: 'float'
            },
            {
                name: 'type',
                type: 'int'
            },
            {
                name: 'title',
                type: 'string'
            },
            {
                name: 'date',
                type: 'date'
            }
        ],
        proxy: {
            type: 'localstorage',
            id: 'poi'
        }
    }
});
/*
 * File: app/controller/MapHandler.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.MapHandler', {
    extend: 'Ext.app.Controller',

    config: {
        autoCenter: 'undef',
        currPos: 'undef',
        currPosMark: 'undef',
        landingLines: 'undef',
        landingMarkers: 'undef',
        walkPath: 'undef',
        landingMarkersLabels: 'undef',
        mapHeading: 'undef',
        compassHeading: 'undef',
        stores: [
            'WalkPointData'
        ],
        views: [
            'main'
        ],

        refs: {
            map: '#googleMap'
        },

        control: {
            "#googleMap": {
                centerchange: 'onMapCenterChange',
                maprender: 'onMapMaprender'
            },
            "#useLocation": {
                tap: 'onImageTap'
            }
        }
    },

    onMapCenterChange: function(map, gmap, center, options) {
        //console.log('CenterChanged!!! New center is ' + center.toString());

    },

    onMapMaprender: function(map, gmap, options) {

    },

    onImageTap: function(img, e, options) {
        var map = this.getMap();
        console.log('map.getUseCurrentLocation() before: ' + this.getAutoCenter());
        if(this.getAutoCenter()) {    
            this.setAutoCenter(false);
            map.useCurrentLocation = false;
            img.setSrc('./data/useCurrentOff.png');
        } else {
            this.setAutoCenter(true);
            img.setSrc('./data/useCurrentOn.png');
        }

        console.log('map.getUseCurrentLocation() after: ' + this.getAutoCenter());

    },

    launch: function() {
        console.log('map render Was Called');

        // this.addFireBug();
        this.initMap();
        this.initWalkingPath();
        this.initLandingLines();

        this.setAutoCenter(true);
        this.setCurrPos(null);
        this.setCurrPosMark(null);

    },

    initLandingLines: function() {
        this.setLandingLines([]);
        this.setLandingMarkers([]);
        this.setLandingMarkersLabels([]);

        console.log('mapHandler - initLandingLines - getting Store:');
        var landingLineStore = Ext.getStore('LandingLineStore');
        console.log(landingLineStore);
        landingLineStore.load();

        // To do remove:
        var landingLineStoreSize = landingLineStore.getCount();
        console.log('mapHandler - initLandingLines - lines store size:' + landingLineStoreSize);

        var controller = this;
        landingLineStore.each(function(currLine) {
            var startPoint = new google.maps.LatLng(currLine.get('startLat'),currLine.get('startLng'));
            var endPoint = new google.maps.LatLng(currLine.get('endLat'),currLine.get('endLng'));
            controller.drawLineInternal(startPoint, endPoint, currLine.get('title'));
        });
    },

    initMap: function() {
        var mapTypes = [google.maps.MapTypeId.HYBRID,
        google.maps.MapTypeId.SATELLITE,
        google.maps.MapTypeId.ROADMAP,
        google.maps.MapTypeId.TERRAIN];


        var controlOptions = { mapTypeIds:mapTypes,
            position:google.maps.ControlPosition.TOP_RIGHT, 
            style:google.maps.MapTypeControlStyle.DROPDOWN_MENU
        };
        var map = this.getMap();
        var mapOptions = {

            // phili: 39.958636,-75.20496
            // lost hills: 35.6669 , -119.78055
            // Tzeelim: 31.291681,34.574133
            center: new google.maps.LatLng(35.6669 , -119.78055),
            zoom: 14,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            mapTypeControlOptions: controlOptions,
            rotateControl:true,
            streetViewControl:false,
            scaleControl:true
        };

        map.setMapOptions(mapOptions);
        //map.el.dom.style.webkitTransform ='rotate(' + '45' + 'deg)';
        //console.log('rotating');
        //map.element.dom.style.webkitTransform ='rotate(' + '45' + 'deg)';
        //alert('rot');
        //console.log('rotated');
        this.setMapHeading(0);
        this.setCompassHeading(0);

    },

    initWalkingPath: function() {
        var googleWalkPath = new google.maps.Polyline({
            strokeColor: "#5882FA",
            strokeOpacity: 0.7,
            strokeWeight: 3,
            map:this.getMap().getMap(),
            geodesic:true
        });


        console.log('mapHandler - initWalkingPath - getting WalkPointDataStore:');
        var walkPointStore = Ext.getStore('WalkPointStore');
        console.log(walkPointStore);
        walkPointStore.load();

        // To do remove:
        var walkPointStoreSize = walkPointStore.getCount();
        console.log('mapHandler - initWalkingPath - path store size:' + walkPointStoreSize);


        var walkPathArray = googleWalkPath.getPath();

        walkPointStore.each(function(currWalkPoint) {
            var latlng = new google.maps.LatLng(currWalkPoint.get('lat'),currWalkPoint.get('lng'));
            walkPathArray.push(latlng);
        });


        this.setWalkPath(googleWalkPath);

    },

    addFireBug: function() {
        // Add firebug lite.
        (function (F, i, r, e, b, u, g, L, I, T, E) {
            if (F.getElementById(b)) return;
            E = F[i + 'NS'] && F.documentElement
            .namespaceURI;
            E = E ? F[i + 'NS'](E, 'script') : F[i]('script');
            E[r]('id', b);
            E[r]('src', I + g + T);
            E[r](b, u);
            (F[e]('head')[0] || F[e]('body')[0]).appendChild(E);
            E = new Image;
            E[r]('src', I + L);
        })(document, 'createElement', 'setAttribute', 'getElementsByTagName', 'FirebugLite', '4', 'firebug-lite.js', 'releases/lite/latest/skin/xp/sprite.png', 'https://getfirebug.com/', '#startOpened');
    },

    drawLine: function(distance, bearing, title) {
        console.log('drawLine was called! bearing: ' + bearing + ' distance:' + distance + ' title: ' + title);

        var currPos = this.getCurrPos();

        // To do: - implement magnetic north!

        Number.prototype.toRad = function() {
            return this * Math.PI / 180;
        };

        Number.prototype.toDeg = function() {
            return this * 180 / Math.PI;
        };

        // dist - in meters.
        google.maps.LatLng.prototype.destinationPoint = function(brng, dist) {
            console.log('MapHelper - clacDest point - brng is:' + brng + ', dist is: ' + dist );


            dist = dist / 6371;
            dist = dist / 1000;

            brng = parseFloat(brng);
            console.log('drawLine was called! brng: ' + brng + ' dist:' + dist);
            brng = brng.toRad();  

            var lat1 = currPos.lat().toRad(), lon1 = currPos.lng().toRad();

            var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist) + 
            Math.cos(lat1) * Math.sin(dist) * Math.cos(brng));

            var lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(dist) *
            Math.cos(lat1), 
            Math.cos(dist) - Math.sin(lat1) *
            Math.sin(lat2));

            if (isNaN(lat2) || isNaN(lon2)) return null;

            return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());
        };

        //////////
        var coordsHelpersController = this.getApplication().getController('CoordsHelpers');
        var dec = coordsHelpersController.getDeclination(currPos.lat(), currPos.lng());
        console.log('MapHelper - drawLine - declination is:' + dec);

        // Add declination.
        // To do: check if needed to add or reduce declination!
        bearing = (parseFloat(bearing) + dec + 360) % 360;

        var endPoint = currPos.destinationPoint(bearing, distance);
        console.log('MapHelper - drawLine - end point:');
        console.log(endPoint);


        this.drawLineInternal(currPos, endPoint, title);


        var currLineObj = Ext.create('RetModel.model.landingLine', {
            startLat: currPos.lat(),
            startLng: currPos.lng(),
            endLat: endPoint.lat(),
            endLng: endPoint.lng(),
            title:title,
            date: new Date()
        }
        );
        currLineObj.save();


    },

    drawLineInternal: function(startPoint, endPoint, title) {


        // Define the overlay, derived from google.maps.OverlayView
        function Label(opt_options) {
            // Initialization
            this.setValues(opt_options);

            // Here go the label styles
            var span = this.span_ = document.createElement('span');
            span.style.cssText = 'position: relative; left: -50%; top: -35px; ' +
            'white-space: nowrap;color:#FF0000;' +
            'padding: 2px;font-family: Arial; font-weight: bold;' +
            'font-size: 14px;';

            var div = this.div_ = document.createElement('div');
            div.appendChild(span);
            div.style.cssText = 'position: absolute; display: none';
        };

        Label.prototype = new google.maps.OverlayView;

        Label.prototype.onAdd = function() {
            var pane = this.getPanes().overlayImage;
            pane.appendChild(this.div_);

            // Ensures the label is redrawn if the text or position is changed.
            var me = this;
            this.listeners_ = [
            google.maps.event.addListener(this, 'position_changed',
            function() { me.draw(); }),
            google.maps.event.addListener(this, 'text_changed',
            function() { me.draw(); }),
            google.maps.event.addListener(this, 'zindex_changed',
            function() { me.draw(); })
            ];
        };

        // Implement onRemove
        Label.prototype.onRemove = function() {
            this.div_.parentNode.removeChild(this.div_);

            // Label is removed from the map, stop updating its position/text.
            for (var i = 0, I = this.listeners_.length; i < I; ++i) {
                google.maps.event.removeListener(this.listeners_[i]);
            }
        };

        // Implement draw
        Label.prototype.draw = function() {
            var projection = this.getProjection();
            var position = projection.fromLatLngToDivPixel(this.get('position'));
            var div = this.div_;
            div.style.left = position.x + 'px';
            div.style.top = position.y + 'px';
            div.style.display = 'block';
            div.style.zIndex = this.get('zIndex'); //ALLOW LABEL TO OVERLAY MARKER
            this.span_.innerHTML = this.get('text').toString();
        };


        /////////////////////////
        var map = this.getMap().getMap();

        var image = new google.maps.MarkerImage('data/airplane.png',
        // This marker is 32 pixels wide by 32 pixels tall.
        new google.maps.Size(48, 48),
        // The origin for this image is 0,0.
        new google.maps.Point(0,0),
        // The anchor for this image is the middle.
        new google.maps.Point(24, 24));

        /*
        var shape = {
        coord: [10, 10, 10 , 10],
        type: 'rect'
        };
        */

        var marker = new google.maps.Marker({
            position: endPoint,
            map: map,
            clickable:true,
            icon: image,
            // To do: fix shape!
            //shape: shape,
            cursor:'help',
            flat:true, //no shadow
            animation: google.maps.Animation.DROP,
            zIndex:10,
            // To do: make popup message.
            title:title
        });

        var landingMarkersArr = this.getLandingMarkers();
        landingMarkersArr.push(marker);

        var label = new Label({
            map: map
        });
        label.set('zIndex', 1234);
        label.bindTo('position', marker, 'position');
        label.set('text', title);
        //label.bindTo('text', marker, 'position');

        var labelsMarkersArr = this.getLandingMarkersLabels();
        labelsMarkersArr.push(label);

        var line = new google.maps.Polyline({
            path: [startPoint, endPoint],
            strokeColor: "#FF0000",
            strokeOpacity: 0.8,
            strokeWeight: 4,
            map: map
        });

        var landingLinesArr = this.getLandingLines();
        landingLinesArr.push(line);











    },

    updateCurrPosMarker: function(lat, long) {
        if (lat === undefined || long === undefined) {
            console.log('updateCurrPosMarker - params undef, returning. vals: ' + lat + ' ' + long);
            return;
        }

        //console.log('updateCurrPosMarker was called. params: ' + lat + ' ' + long);

        var map = this.getMap();
        if (map === undefined) {
            console.log('updateCurrPosMarker - googleMap undef, returning. vals: ' + map);
            return;
        }
        var googleMap = map.getMap();

        var latlng = new google.maps.LatLng(lat,long);

        var oldPos = this.getCurrPos();
        var prevPoint = oldPos;
        if (oldPos === null) {
            console.log('updateCurrPosMarker - oldPos === null');

            prevPoint = latlng;
        }

        var coordsHelpersController = this.getApplication().getController('CoordsHelpers');
        var distBearing = coordsHelpersController.calcDistBearing(prevPoint, latlng);

        //console.log('updateCurrPosMarker - distBearing: ');
        //console.log(distBearing);

        var distance = distBearing[0];
        var bearing = distBearing[1];

        if (this.getAutoCenter()) {
            //console.log('updateCurrPosMarker - panning!');
            googleMap.panTo(latlng);
            var currHeading = this.getMapHeading();
            //if (Math.abs(currHeading - bearing) > 15) {
            //if (Math.abs(currHeading - bearing) > 5) {
            //  console.log('updateCurrPosMarker - setting map heading to: ' + bearing);

            //googleMap.setHeading(bearing);
            // map.element.dom.style.webkitTransform ='rotate(-' + bearing + 'deg)';
            //googleMap.element.dom.style.webkitTransform ='rotate(' + '45' + 'deg)';

            //this.setMapHeading(bearing);  
            //}
        }


        // If there was no change in movement (less then 3 meters) return.
        if((oldPos !== null) && (distance < 3)) {
            console.log('updateCurrPosMarker - no change, returning.');
            return;
        }

        this.setCurrPos(latlng);

        var marker = this.getCurrPosMark();

        if (marker === null) {   
            var image = new google.maps.MarkerImage('data/currLocation_org.png',
            // This marker is 32 pixels wide by 32 pixels tall.
            new google.maps.Size(32, 32),
            // The origin for this image is 0,0.
            new google.maps.Point(0,0),
            // The anchor for this image is the middle.
            //new google.maps.Point(8, 8));
            new google.maps.Point(16, 16));

            marker = new google.maps.Marker({
                position: latlng,
                clickable:false,
                map: googleMap,
                //icon: image,
                icon: {
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                    rotation: 270,
                    scale: 5,
                    strokeColor: '#0101DF',
                    strokeWeight: 2,
                    anchor: new google.maps.Point(0,2)
                },
                cursor:'help',
                flat:true, //no shadow
                //  animation: google.maps.Animation.DROP,
                zIndex:11
            });

            this.setCurrPosMark(marker);
        }

        marker.setPosition(latlng);

        var dec = coordsHelpersController.getDeclination(lat, long);
        var decBearing = bearing + dec;
        marker.setIcon({
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            rotation: ((decBearing - this.getMapHeading() + 360) % 360),
            scale: 5,
            strokeColor: '#0101DF',
            strokeWeight: 2,
            anchor: new google.maps.Point(0,2)
        });

        var walkPathArray = this.getWalkPath().getPath();
        walkPathArray.push(latlng);


        var currWalkPoint = Ext.create('RetModel.model.walkPoint', {
            lng: long,
            lat: lat,
            date: new Date()
        }
        );
        currWalkPoint.save();


    },

    updateCurrPosHeading: function(bearing) {
        var marker = this.getCurrPosMark();

        if (marker === null) {   
            return;
        }

        var currPos = this.getCurrPos();
        var coordsHelpersController = this.getApplication().getController('CoordsHelpers');
        var dec = coordsHelpersController.getDeclination(currPos.lat(), currPos.lng());
        var decBearing = bearing + dec;
        marker.setIcon({
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            rotation: ((decBearing - this.getMapHeading() + 360) % 360),
            scale: 5,
            strokeColor: '#0101DF',
            strokeWeight: 2,
            anchor: new google.maps.Point(0,2)
        });
    }

});
/*
 * File: app/controller/MapCleaner.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.MapCleaner', {
    extend: 'Ext.app.Controller',

    config: {
        stores: [
            'WalkPointData',
            'LandingLineData'
        ],

        control: {
            "#clearBearingBtn": {
                tap: 'onClearBearingBtnTap'
            },
            "#clearPathBtn": {
                tap: 'onClearPathBtnTap'
            }
        }
    },

    onClearBearingBtnTap: function(button, e, options) {
        console.info('ClearMap - onClearBearingBtnTap - called! landingLinesArr:');

        var mapHandlerController = this.getApplication().getController('MapHandler');
        var landingLinesArr = mapHandlerController.getLandingLines();
        var landingMarkersArr = mapHandlerController.getLandingMarkers();
        var landingMarkersLabelsArr = mapHandlerController.getLandingMarkersLabels();

        console.info(landingMarkersArr);

        for (var index in landingLinesArr) {
            landingLinesArr[index].setMap(null);
        }
        console.info('ClearMap - onClearBearingBtnTap - set lines to null.');

        landingLinesArr.length = 0;

        console.info('ClearMap - onClearBearingBtnTap - cleared lines.');

        for (var markIndex in landingMarkersArr) {
            landingMarkersArr[markIndex].setMap(null);
        }

        console.info('ClearMap - onClearBearingBtnTap - clearing labels.');
        console.info(landingMarkersLabelsArr);

        for (var labelIndex in landingMarkersLabelsArr) {
            landingMarkersLabelsArr[labelIndex].setMap(null);
        }
        console.info('ClearMap - onClearBearingBtnTap - cleared labels.');


        console.info('ClearMap - onClearBearingBtnTap - set markers to null.');
        landingMarkersArr.length = 0;
        landingMarkersLabelsArr.length = 0;

        console.info('ClearMap - onClearBearingBtnTap - cleared lines.');

        console.info(landingMarkersArr);

        var landingLineStore = Ext.getStore('LandingLineStore');
        landingLineStore.load();
        landingLineStore.removeAll(landingLineStore.getRange());
    },

    onClearPathBtnTap: function(button, e, options) {
        console.info('ClearMap - onClearPathBtnTap - called! walkPathArray:');
        var mapHandlerController = this.getApplication().getController('MapHandler');
        var walkPathArray = mapHandlerController.getWalkPath().getPath();

        walkPathArray.clear();

        var walkPointStore = Ext.getStore('WalkPointStore');
        walkPointStore.load();
        walkPointStore.removeAll(walkPointStore.getRange());

    }

});
/*
 * File: app/store/GpsData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.store.GpsData', {
    extend: 'Ext.data.Store',

    requires: [
        'RetModel.model.gpsData'
    ],

    config: {
        autoLoad: true,
        autoSync: true,
        clearOnPageLoad: false,
        model: 'RetModel.model.gpsData',
        storeId: 'GpsDataStore'
    }
});
/*
 * File: app/controller/DevicesFormsUpdater.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.DevicesFormsUpdater', {
    extend: 'Ext.app.Controller',

    config: {
        views: [
            'main'
        ],

        refs: {
            gpsForm: '#gpsData',
            compassForm: '#compassData',
            bearingLineForm: '#newBearingLine'
        }
    },

    launch: function() {
        console.log('DevicesFormsUpdater was launched!');
        //this.updateGps();
        //this.updateCompass();
    },

    convertDateTime: function(dateTimeObj) {
        var curr_date = dateTimeObj.getDate();
        var curr_month = dateTimeObj.getMonth() + 1;
        var curr_year = dateTimeObj.getFullYear();
        var curr_hour = dateTimeObj.getHours();
        var curr_min = dateTimeObj.getMinutes();
        var curr_sec = dateTimeObj.getSeconds();
        var curr_msec = dateTimeObj.getMilliseconds();

        return curr_date + "-" + curr_month + "-" + curr_year + " " + curr_hour + ":" + curr_min + ":" + curr_sec + ":" + curr_msec;  
    },

    updateGps: function(gpsRec) {

        var gpsForm = this.getGpsForm();

        var currGpsRead = parseFloat(gpsForm.getValues().num);
        currGpsRead = (currGpsRead + 1);

        var measureDateTime = this.convertDateTime(gpsRec.get('date'));

        gpsForm.setRecord(gpsRec);
        gpsForm.setValues({date:measureDateTime});
        gpsForm.setValues({formUpdated:this.convertDateTime(new Date())});
        gpsForm.setValues({num:currGpsRead});




    },

    updateCompass: function(compassRec) {
        var compassForm = this.getCompassForm();

        var currCompassRead = parseFloat(compassForm.getValues().num);
        currCompassRead = (currCompassRead + 1);

        var measureDateTime = this.convertDateTime(compassRec.get('date'));


        // To do: call real dec!
        //var coordsHelpersController = this.getApplication().getController('CoordsHelpers');
        //var dec = coordsHelpersController.getDeclination(currPos.lat(), currPos.lng());
        var dec = -12.18;

        var fixedPos = (parseFloat(compassRec.get('bearing')) + dec + 360) % 360;
        var fixedNeg = (parseFloat(compassRec.get('bearing')) - dec + 360) % 360;


        compassForm.setRecord(compassRec);
        compassForm.setValues({fixedPos:fixedPos});
        compassForm.setValues({fixedNeg:fixedNeg});
        compassForm.setValues({date:measureDateTime});
        compassForm.setValues({formUpdated:this.convertDateTime(new Date())});
        compassForm.setValues({num:currCompassRead});

    },

    updateBearingCompass: function(heading) {
        var bearingLineForm = this.getBearingLineForm();

        var shouldUseCompass = parseFloat(bearingLineForm.getValues().useCompass);
        if(shouldUseCompass === 0) {
            return;
        }

        compassForm.setValues({bearing:heading});

    }

});
/*
 * File: app/store/Conf.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.store.Conf', {
    extend: 'Ext.data.Store',

    requires: [
        'RetModel.model.conf'
    ],

    config: {
        autoLoad: true,
        autoSync: true,
        clearOnPageLoad: false,
        model: 'RetModel.model.conf',
        storeId: 'ConfStore'
    }
});
/*
 * File: app/store/CompassData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.store.CompassData', {
    extend: 'Ext.data.Store',

    requires: [
        'RetModel.model.compassData'
    ],

    config: {
        autoLoad: true,
        autoSync: true,
        clearOnPageLoad: false,
        model: 'RetModel.model.compassData',
        storeId: 'CompassDataStore'
    }
});
/*
 * File: app/store/poiData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.store.poiData', {
    extend: 'Ext.data.Store',

    requires: [
        'RetModel.model.poi'
    ],

    config: {
        autoLoad: true,
        autoSync: true,
        clearOnPageLoad: false,
        model: 'RetModel.model.poi',
        storeId: 'poiStore'
    }
});
/*
 * File: app/controller/DrawBearingLine.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.DrawBearingLine', {
    extend: 'Ext.app.Controller',

    config: {
        models: [
            'landingLine'
        ],
        views: [
            'main'
        ],

        refs: {
            lineForm: '#newBearingLine',
            mainView: '#mainView'
        },

        control: {
            "#drawLineBtn": {
                tap: 'onButtonTap'
            }
        }
    },

    onButtonTap: function(button, e, options) {
        var lineForm = this.getLineForm();
        var values = lineForm.getValues();
        var bearing = values.bearing;
        var distance = values.distance;
        var title = values.title;
        console.log('DrawBearingLine - got values. bearing: ' + bearing + ' distance:' + distance + 'title: ' + title);

        var mapHandlerController = this.getApplication().getController('MapHandler').drawLine(distance, bearing, title);

        this.getMainView().setActiveItem(0);
    }

});
/*
 * File: app/store/LandingLineData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.store.LandingLineData', {
    extend: 'Ext.data.Store',

    requires: [
        'RetModel.model.landingLine'
    ],

    config: {
        autoLoad: true,
        autoSync: true,
        clearOnPageLoad: false,
        model: 'RetModel.model.landingLine',
        storeId: 'LandingLineStore'
    }
});
/*
 * File: app/controller/Conf.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.Conf', {
    extend: 'Ext.app.Controller',

    config: {
    }
});
/*
 * File: app/controller/CoordsHelpers.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.CoordsHelpers', {
    extend: 'Ext.app.Controller',

    config: {
        decModule: 'undef'
    },

    launch: function() {
        this.initDecModule();
    },

    initDecModule: function() {
        /* DOD World Magnetic Model 2010-2015 

        See bottom of file for info from original Fortran source code 

        Reminder - this is just a model! See the USGS and BGS sites for predicted accuracy.

        Usage is 

        var wmm = new WorldMagneticModel();

        then

        var dec = wmm.declination(0.0, 59.0, -2.0, 2010.5); 

        parameters are 
        altitude in kilometres
        decimal degree latitude, -ve for south
        decimal degree longitude, -ve for west
        date as year + fraction of year

        return is declination angle in decimal degrees, 
        +ve for Magnetic North East of True North
        (-999 for < 2010.0 and >= 2015.0)

        The method knownAnswerTest yields a maximum declination error of 0.007% on the small 2010 USGS test data set. 
        The maximum error is at 80S latitude, 120W longitude. The value produced by this code at this point is 70.215 degrees.
        This is the same answer as produced by the BGS calculator at http://www.geomag.bgs.ac.uk/gifs/wmm_calc.html

        This javascript port by Bill Chadwick, 27-Oct-2008, updated with 2010 coefficients on 3 Jan 2010 
        email: w.chadwick<at>sky.com

        */
        function WorldMagneticModel() {

            /* 2010 - 2015 coefficients from WMM.COF */

            this.coff = ["  1,  0,  -29496.6  ,    0.0     ,   11.6  ,      0.0", "  1,  1,   -1586.3  ,  4944.4    ,   16.5  ,    -25.9", "  2,  0,   -2396.6  ,     0.0    ,  -12.1  ,      0.0", "  2,  1,    3026.1  , -2707.7    ,   -4.4  ,    -22.5", "  2,  2,    1668.6  ,  -576.1    ,    1.9  ,    -11.8", "  3,  0,    1340.1  ,     0.0    ,    0.4  ,      0.0", "  3,  1,   -2326.2  ,  -160.2    ,   -4.1  ,      7.3", "  3,  2,    1231.9  ,   251.9    ,   -2.9  ,     -3.9", "  3,  3,     634.0  ,  -536.6    ,   -7.7  ,     -2.6", "  4,  0,     912.6  ,     0.0    ,   -1.8  ,      0.0", "  4,  1,     808.9  ,   286.4    ,    2.3  ,      1.1", "  4,  2,     166.7  ,  -211.2    ,   -8.7  ,      2.7", "  4,  3,    -357.1  ,   164.3    ,    4.6  ,      3.9", "  4,  4,      89.4  ,  -309.1    ,   -2.1  ,     -0.8", "  5,  0,    -230.9  ,     0.0    ,   -1.0  ,      0.0", "  5,  1,     357.2  ,    44.6    ,    0.6  ,      0.4", "  5,  2,     200.3  ,   188.9    ,   -1.8  ,      1.8", "  5,  3,    -141.1  ,  -118.2    ,   -1.0  ,      1.2", "  5,  4,    -163.0  ,     0.0    ,    0.9  ,      4.0", "  5,  5,      -7.8  ,   100.9    ,    1.0  ,     -0.6", "  6,  0,      72.8  ,     0.0    ,   -0.2  ,      0.0", "  6,  1,      68.6  ,   -20.8    ,   -0.2  ,     -0.2", "  6,  2,      76.0  ,    44.1    ,   -0.1  ,     -2.1", "  6,  3,    -141.4  ,    61.5    ,    2.0  ,     -0.4", "  6,  4,     -22.8  ,   -66.3    ,   -1.7  ,     -0.6", "  6,  5,      13.2  ,     3.1    ,   -0.3  ,      0.5", "  6,  6,     -77.9  ,    55.0    ,    1.7  ,      0.9", "  7,  0,      80.5  ,     0.0    ,    0.1  ,      0.0", "  7,  1,     -75.1  ,   -57.9    ,   -0.1  ,      0.7", "  7,  2,      -4.7  ,   -21.1    ,   -0.6  ,      0.3", "  7,  3,      45.3  ,     6.5    ,    1.3  ,     -0.1", "  7,  4,      13.9  ,    24.9    ,    0.4  ,     -0.1", "  7,  5,      10.4  ,     7.0    ,    0.3  ,     -0.8", "  7,  6,       1.7  ,   -27.7    ,   -0.7  ,     -0.3", "  7,  7,       4.9  ,    -3.3    ,    0.6  ,      0.3", "  8,  0,      24.4  ,     0.0    ,   -0.1  ,      0.0", "  8,  1,       8.1  ,    11.0    ,    0.1  ,     -0.1", "  8,  2,     -14.5  ,   -20.0    ,   -0.6  ,      0.2", "  8,  3,      -5.6  ,    11.9    ,    0.2  ,      0.4", "  8,  4,     -19.3  ,   -17.4    ,   -0.2  ,      0.4", "  8,  5,      11.5  ,    16.7    ,    0.3  ,      0.1", "  8,  6,      10.9  ,     7.0    ,    0.3  ,     -0.1", "  8,  7,     -14.1  ,   -10.8    ,   -0.6  ,      0.4", "  8,  8,      -3.7  ,     1.7    ,    0.2  ,      0.3", "  9,  0,       5.4  ,     0.0    ,    0.0  ,      0.0", "  9,  1,       9.4  ,   -20.5    ,   -0.1  ,      0.0", "  9,  2,       3.4  ,    11.5    ,    0.0  ,     -0.2", "  9,  3,      -5.2  ,    12.8    ,    0.3  ,      0.0", "  9,  4,       3.1  ,    -7.2    ,   -0.4  ,     -0.1", "  9,  5,     -12.4  ,    -7.4    ,   -0.3  ,      0.1", "  9,  6,      -0.7  ,     8.0    ,    0.1  ,      0.0", "  9,  7,       8.4  ,     2.1    ,   -0.1  ,     -0.2", "  9,  8,      -8.5  ,    -6.1    ,   -0.4  ,      0.3", "  9,  9,     -10.1  ,     7.0    ,   -0.2  ,      0.2", " 10,  0,      -2.0  ,     0.0    ,    0.0  ,      0.0", " 10,  1,      -6.3  ,     2.8    ,    0.0  ,      0.1", " 10,  2,       0.9  ,    -0.1    ,   -0.1  ,     -0.1", " 10,  3,      -1.1  ,     4.7    ,    0.2  ,      0.0", " 10,  4,      -0.2  ,     4.4    ,    0.0  ,     -0.1", " 10,  5,       2.5  ,    -7.2    ,   -0.1  ,     -0.1", " 10,  6,      -0.3  ,    -1.0    ,   -0.2  ,      0.0", " 10,  7,       2.2  ,    -3.9    ,    0.0  ,     -0.1", " 10,  8,       3.1  ,    -2.0    ,   -0.1  ,     -0.2", " 10,  9,      -1.0  ,    -2.0    ,   -0.2  ,      0.0", " 10, 10,      -2.8  ,    -8.3    ,   -0.2  ,     -0.1", " 11,  0,       3.0  ,     0.0    ,    0.0  ,      0.0", " 11,  1,      -1.5  ,     0.2    ,    0.0  ,      0.0", " 11,  2,      -2.1  ,     1.7    ,    0.0  ,      0.1", " 11,  3,       1.7  ,    -0.6    ,    0.1  ,      0.0", " 11,  4,      -0.5  ,    -1.8    ,    0.0  ,      0.1", " 11,  5,       0.5  ,     0.9    ,    0.0  ,      0.0", " 11,  6,      -0.8  ,    -0.4    ,    0.0  ,      0.1", " 11,  7,       0.4  ,    -2.5    ,    0.0  ,      0.0", " 11,  8,       1.8  ,    -1.3    ,    0.0  ,     -0.1", " 11,  9,       0.1  ,    -2.1    ,    0.0  ,     -0.1", " 11, 10,       0.7  ,    -1.9    ,   -0.1  ,      0.0", " 11, 11,       3.8  ,    -1.8    ,    0.0  ,     -0.1", " 12,  0,      -2.2  ,     0.0    ,    0.0  ,      0.0", " 12,  1,      -0.2  ,    -0.9    ,    0.0  ,      0.0", " 12,  2,       0.3  ,     0.3    ,    0.1  ,      0.0", " 12,  3,       1.0  ,     2.1    ,    0.1  ,      0.0", " 12,  4,      -0.6  ,    -2.5    ,   -0.1  ,      0.0", " 12,  5,       0.9  ,     0.5    ,    0.0  ,      0.0", " 12,  6,      -0.1  ,     0.6    ,    0.0  ,      0.1", " 12,  7,       0.5  ,     0.0    ,    0.0  ,      0.0", " 12,  8,      -0.4  ,     0.1    ,    0.0  ,      0.0", " 12,  9,      -0.4  ,     0.3    ,    0.0  ,      0.0", " 12, 10,       0.2  ,    -0.9    ,    0.0  ,      0.0", " 12, 11,      -0.8  ,    -0.2    ,   -0.1  ,      0.0", " 12, 12,       0.0  ,     0.9    ,    0.1  ,      0.0"];

            /* static variables */

            /* some 13x13 2D arrays */
            this.c = new Array(13);
            this.cd = new Array(13);
            this.tc = new Array(13);
            this.dp = new Array(13);
            this.k = new Array(13);

            for (var i = 0; i < 13; i++) {
                this.c[i] = new Array(13);
                this.cd[i] = new Array(13);
                this.tc[i] = new Array(13);
                this.dp[i] = new Array(13);
                this.k[i] = new Array(13);
            }

            /* some 1D arrays */
            this.snorm = new Array(169);
            this.sp = new Array(13);
            this.cp = new Array(13);
            this.fn = new Array(13);
            this.fm = new Array(13);
            this.pp = new Array(13);


            /* locals */

            var maxdeg = 12;
            var maxord;
            var i, j, D1, D2, n, m;
            var a, b, a2, b2, c2, a4, b4, c4, re;
            var gnm, hnm, dgnm, dhnm, flnmj;
            var c_str;
            var c_flds;

            /* INITIALIZE CONSTANTS */

            maxord = maxdeg;
            this.sp[0] = 0.0;
            this.cp[0] = this.snorm[0] = this.pp[0] = 1.0;
            this.dp[0][0] = 0.0;
            a = 6378.137;
            b = 6356.7523142;
            re = 6371.2;
            a2 = a * a;
            b2 = b * b;
            c2 = a2 - b2;
            a4 = a2 * a2;
            b4 = b2 * b2;
            c4 = a4 - b4;

            /* READ WORLD MAGNETIC MODEL SPHERICAL HARMONIC COEFFICIENTS */
            this.c[0][0] = 0.0;
            this.cd[0][0] = 0.0;

            for (i = 0; i < this.coff.length; i++) {
                c_str = this.coff[i];
                c_flds = c_str.split(",");

                n = parseInt(c_flds[0], 10);
                m = parseInt(c_flds[1], 10);
                gnm = parseFloat(c_flds[2]);
                hnm = parseFloat(c_flds[3]);
                dgnm = parseFloat(c_flds[4]);
                dhnm = parseFloat(c_flds[5]);

                if (m <= n) {
                    this.c[m][n] = gnm;
                    this.cd[m][n] = dgnm;
                    if (m != 0) {
                        this.c[n][m - 1] = hnm;
                        this.cd[n][m - 1] = dhnm;
                    }
                }
            }

            /* CONVERT SCHMIDT NORMALIZED GAUSS COEFFICIENTS TO UNNORMALIZED */

            this.snorm[0] = 1.0;
            for (n = 1; n <= maxord; n++) {
                this.snorm[n] = this.snorm[n - 1] * (2 * n - 1) / n;
                j = 2;
                for (m = 0, D1 = 1, D2 = (n - m + D1) / D1; D2 > 0; D2--, m += D1) {
                    this.k[m][n] = (((n - 1) * (n - 1)) - (m * m)) / ((2 * n - 1) * (2 * n - 3));
                    if (m > 0) {
                        flnmj = ((n - m + 1) * j) / (n + m);
                        this.snorm[n + m * 13] = this.snorm[n + (m - 1) * 13] * Math.sqrt(flnmj);
                        j = 1;
                        this.c[n][m - 1] = this.snorm[n + m * 13] * this.c[n][m - 1];
                        this.cd[n][m - 1] = this.snorm[n + m * 13] * this.cd[n][m - 1];
                    }
                    this.c[m][n] = this.snorm[n + m * 13] * this.c[m][n];
                    this.cd[m][n] = this.snorm[n + m * 13] * this.cd[m][n];
                }
                this.fn[n] = (n + 1);
                this.fm[n] = n;
            }
            this.k[1][1] = 0.0;
            this.fm[0] = 0.0; // !!!!!! WMM C and Fortran both have a bug in that fm[0] is not initialised 

        }

        WorldMagneticModel.prototype.declination = function (altitudeKm, latitudeDegrees, longitudeDegrees, yearFloat) {



            /* locals */

            var a = 6378.137;
            var b = 6356.7523142;
            var re = 6371.2;
            var a2 = a * a;
            var b2 = b * b;
            var c2 = a2 - b2;
            var a4 = a2 * a2;
            var b4 = b2 * b2;
            var c4 = a4 - b4;
            var D3, D4;
            var dip, ti, gv, dec;
            var n, m;

            var pi, dt, rlon, rlat, srlon, srlat, crlon, crlat, srlat2,
            crlat2, q, q1, q2, ct, d, aor, ar, br, r2, bpp, par,
            temp1, parp, temp2, bx, by, bz, bh, dtr, bp, bt, st, ca, sa;

            var maxord = 12;
            var alt = altitudeKm;
            var glon = longitudeDegrees;
            var glat = latitudeDegrees;

            /*************************************************************************/

            dt = yearFloat - 2010.0;
            //if more then 5 years has passed since last epoch update then return invalid
            if ((dt < 0.0) || (dt > 5.0)) return -999;


            pi = 3.14159265359;
            dtr = pi / 180.0;
            rlon = glon * dtr;
            rlat = glat * dtr;
            srlon = Math.sin(rlon);
            srlat = Math.sin(rlat);
            crlon = Math.cos(rlon);
            crlat = Math.cos(rlat);
            srlat2 = srlat * srlat;
            crlat2 = crlat * crlat;
            this.sp[1] = srlon;
            this.cp[1] = crlon;

            /* CONVERT FROM GEODETIC COORDS. TO SPHERICAL COORDS. */

            q = Math.sqrt(a2 - c2 * srlat2);
            q1 = alt * q;
            q2 = ((q1 + a2) / (q1 + b2)) * ((q1 + a2) / (q1 + b2));
            ct = srlat / Math.sqrt(q2 * crlat2 + srlat2);
            st = Math.sqrt(1.0 - (ct * ct));
            r2 = (alt * alt) + 2.0 * q1 + (a4 - c4 * srlat2) / (q * q);
            r = Math.sqrt(r2);
            d = Math.sqrt(a2 * crlat2 + b2 * srlat2);
            ca = (alt + d) / r;
            sa = c2 * crlat * srlat / (r * d);

            for (m = 2; m <= maxord; m++) {
                this.sp[m] = this.sp[1] * this.cp[m - 1] + this.cp[1] * this.sp[m - 1];
                this.cp[m] = this.cp[1] * this.cp[m - 1] - this.sp[1] * this.sp[m - 1];
            }

            aor = re / r;
            ar = aor * aor;
            br = bt = bp = bpp = 0.0;

            for (n = 1; n <= maxord; n++) {
                ar = ar * aor;
                for (m = 0, D3 = 1, D4 = (n + m + D3) / D3; D4 > 0; D4--, m += D3) {
                    /*
                    COMPUTE UNNORMALIZED ASSOCIATED LEGENDRE POLYNOMIALS
                    AND DERIVATIVES VIA RECURSION RELATIONS
                    */


                    if (n == m) {
                        this.snorm[n + m * 13] = st * this.snorm[n - 1 + (m - 1) * 13];
                        this.dp[m][n] = st * this.dp[m - 1][n - 1] + ct * this.snorm[n - 1 + (m - 1) * 13];
                    } else if (n == 1 && m == 0) {
                        this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13];
                        this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13];
                    } else if (n > 1 && n != m) {
                        if (m > n - 2) this.snorm[n - 2 + m * 13] = 0.0;
                        if (m > n - 2) this.dp[m][n - 2] = 0.0;
                        this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.snorm[n - 2 + m * 13];
                        this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.dp[m][n - 2];
                    }

                    /*
                    TIME ADJUST THE GAUSS COEFFICIENTS
                    */
                    this.tc[m][n] = this.c[m][n] + dt * this.cd[m][n];
                    if (m != 0) this.tc[n][m - 1] = this.c[n][m - 1] + dt * this.cd[n][m - 1];

                    /*
                    ACCUMULATE TERMS OF THE SPHERICAL HARMONIC EXPANSIONS
                    */
                    par = ar * this.snorm[n + m * 13];
                    if (m == 0) {
                        temp1 = this.tc[m][n] * this.cp[m];
                        temp2 = this.tc[m][n] * this.sp[m];
                    } else {
                        temp1 = this.tc[m][n] * this.cp[m] + this.tc[n][m - 1] * this.sp[m];
                        temp2 = this.tc[m][n] * this.sp[m] - this.tc[n][m - 1] * this.cp[m];
                    }
                    bt = bt - ar * temp1 * this.dp[m][n];
                    bp += (this.fm[m] * temp2 * par);
                    br += (this.fn[n] * temp1 * par);
                    /*
                    SPECIAL CASE:  NORTH/SOUTH GEOGRAPHIC POLES
                    */
                    if (st == 0.0 && m == 1) {
                        if (n == 1) this.pp[n] = this.pp[n - 1];
                        else this.pp[n] = this.ct * this.pp[n - 1] - this.k[m][n] * this.pp[n - 2];
                        parp = ar * this.pp[n];
                        bpp += (this.fm[m] * temp2 * parp);
                    }
                }
            }

            if (st == 0.0) bp = bpp;
            else bp /= st;

            /*
            ROTATE MAGNETIC VECTOR COMPONENTS FROM SPHERICAL TO
            GEODETIC COORDINATES
            */
            bx = -bt * ca - br * sa;
            by = bp;
            bz = bt * sa - br * ca;
            /*
            COMPUTE DECLINATION (DEC), INCLINATION (DIP) AND
            TOTAL INTENSITY (TI)
            */
            bh = Math.sqrt((bx * bx) + (by * by));
            ti = Math.sqrt((bh * bh) + (bz * bz));
            dec = Math.atan2(by, bx) / dtr;
            dip = Math.atan2(bz, bh) / dtr;
            /*
            COMPUTE MAGNETIC GRID VARIATION IF THE CURRENT
            GEODETIC POSITION IS IN THE ARCTIC OR ANTARCTIC
            (I.E. GLAT > +55 DEGREES OR GLAT < -55 DEGREES)

            OTHERWISE, SET MAGNETIC GRID VARIATION TO -999.0
            */
            gv = -999.0;
            if (Math.abs(glat) >= 55.0) {
                if (glat > 0.0 && glon >= 0.0) gv = dec - glon;
                if (glat > 0.0 && glon < 0.0) gv = dec + Math.abs(glon);
                if (glat < 0.0 && glon >= 0.0) gv = dec + glon;
                if (glat < 0.0 && glon < 0.0) gv = dec - Math.abs(glon);
                if (gv > +180.0) gv -= 360.0;
                if (gv < -180.0) gv += 360.0;
            }

            return dec;
        }

        WorldMagneticModel.prototype.knownAnswerTest = function () {

            /* http://www.ngdc.noaa.gov/geomag/WMM WMM2010testvalues.pdf */

            /* Lat	Lon Dec	    */
            /* Lon 240 = 120W, Lon 300 = 60W */

            /* Alt 0 km */
            var kat2010 = ["80.00	,0.00	 ,-6.13	    ", "0.00	,120.00	 ,0.97	    ", "-80.00	,240.00	 ,70.21	    "];

            var kat2012p5 = ["80.00	,0.00	 ,-5.21	    ", "0.00	,120.00	 ,0.88	    ", "-80.00	,240.00	 ,70.04	    "];

            var maxErr = 0.0;

            for (var i = 0; i < kat2010.length; i++) {

                var c_str = kat2010[i];
                var c_flds = c_str.split(",");

                var lat = parseFloat(c_flds[0]);
                var lon = parseFloat(c_flds[1]);
                var exp = parseFloat(c_flds[2]);
                var maxExp;

                var dec = this.declination(0, lat, lon, 2010.0);
                if (Math.abs(dec - exp) > maxErr) {
                    maxErr = Math.abs(dec - exp);
                    maxExp = exp;
                }

            }

            for (var i = 0; i < kat2012p5.length; i++) {

                var c_str = kat2012p5[i];
                var c_flds = c_str.split(",");

                var lat = parseFloat(c_flds[0]);
                var lon = parseFloat(c_flds[1]);
                var exp = parseFloat(c_flds[2]);
                var maxExp;

                var dec = this.declination(0, lat, lon, 2012.5);
                if (Math.abs(dec - exp) > maxErr) {
                    maxErr = Math.abs(dec - exp);
                    maxExp = exp;
                }

            }


            return maxErr * 100 / maxExp; //max % error

        }

        /*

        C***********************************************************************
        C
        C
        C     SUBROUTINE GEOMAG (GEOMAGNETIC FIELD COMPUTATION)
        C
        C
        C***********************************************************************
        C
        C     GEOMAG IS A NATIONAL GEOSPATIAL INTELLIGENCE AGENCY (NGA) STANDARD
        C     PRODUCT.  IT IS COVERED UNDER NGA MILITARY SPECIFICATION:
        C     MIL-W-89500 (1993).
        C
        C***********************************************************************
        C     Contact Information
        C
        C     Software and Model Support
        C     	National Geophysical Data Center
        C     	NOAA EGC/2
        C     	325 Broadway
        C     	Boulder, CO 80303 USA
        C     	Attn: Susan McLean or Stefan Maus
        C     	Phone:  (303) 497-6478 or -6522
        C     	Email:  Susan.McLean@noaa.gov or Stefan.Maus@noaa.gov
        C		Web: http://www.ngdc.noaa.gov/seg/WMM/
        C
        C     Sponsoring Government Agency
        C	   National Geospatial-Intelligence Agency
        C    	   PRG / CSAT, M.S. L-41
        C    	   3838 Vogel Road
        C    	   Arnold, MO 63010
        C    	   Attn: Craig Rollins
        C    	   Phone:  (314) 263-4186
        C    	   Email:  Craig.M.Rollins@Nga.Mil
        C
        C      Original Program By:
        C        Dr. John Quinn
        C        FLEET PRODUCTS DIVISION, CODE N342
        C        NAVAL OCEANOGRAPHIC OFFICE (NAVOCEANO)
        C        STENNIS SPACE CENTER (SSC), MS 39522-5001
        C
        C***********************************************************************
        C
        C     PURPOSE:  THIS ROUTINE COMPUTES THE DECLINATION (DEC),
        C               INCLINATION (DIP), TOTAL INTENSITY (TI) AND
        C               GRID VARIATION (GV - POLAR REGIONS ONLY, REFERENCED
        C               TO GRID NORTH OF A STEREOGRAPHIC PROJECTION) OF THE
        C               EARTH'S MAGNETIC FIELD IN GEODETIC COORDINATES
        C               FROM THE COEFFICIENTS OF THE CURRENT OFFICIAL
        C               DEPARTMENT OF DEFENSE (DOD) SPHERICAL HARMONIC WORLD
        C               MAGNETIC MODEL (WMM.COF).  THE WMM SERIES OF MODELS IS
        C               UPDATED EVERY 5 YEARS ON JANUARY 1ST OF THOSE YEARS
        C               WHICH ARE DIVISIBLE BY 5 (I.E. 2000, 2005, 2010 ETC.)
        C               BY NOAA'S NATIONAL GEOPHYSICAL DATA CENTER IN
        C               COOPERATION WITH THE BRITISH GEOLOGICAL SURVEY (BGS).
        C               THE MODEL IS BASED ON GEOMAGNETIC FIELD MEASUREMENTS
        C               FROM SATELLITE AND GROUND OBSERVATORIES.
        C
        C***********************************************************************
        C
        C     MODEL:  THE WMM SERIES GEOMAGNETIC MODELS ARE COMPOSED
        C             OF TWO PARTS:  THE MAIN FIELD MODEL, WHICH IS
        C             VALID AT THE BASE EPOCH OF THE CURRENT MODEL AND
        C             A SECULAR VARIATION MODEL, WHICH ACCOUNTS FOR SLOW
        C             TEMPORAL VARIATIONS IN THE MAIN GEOMAGNETIC FIELD
        C             FROM THE BASE EPOCH TO A MAXIMUM OF 5 YEARS BEYOND
        C             THE BASE EPOCH.  FOR EXAMPLE, THE BASE EPOCH OF
        C             THE WMM-2005 MODEL IS 2005.0.  THIS MODEL IS THEREFORE
        C             CONSIDERED VALID BETWEEN 2005.0 AND 2010.0. THE
        C             COMPUTED MAGNETIC PARAMETERS ARE REFERENCED TO THE
        C             WGS-84 ELLIPSOID.
        C
        C***********************************************************************
        C
        C     ACCURACY:  IN OCEAN AREAS AT THE EARTH'S SURFACE OVER THE
        C                ENTIRE 5 YEAR LIFE OF THE DEGREE AND ORDER 12
        C                SPHERICAL HARMONIC MODEL WMM-2005, THE ESTIMATED
        C                MAXIMUM RMS ERRORS FOR THE VARIOUS MAGNETIC COMPONENTS
        C                ARE:
        C
        C                DEC  -   0.5 Degrees
        C                DIP  -   0.5 Degrees
        C                TI   - 280.0 nanoTeslas (nT)
        C                GV   -   0.5 Degrees
        C
        C                OTHER MAGNETIC COMPONENTS THAT CAN BE DERIVED FROM
        C                THESE FOUR BY SIMPLE TRIGONOMETRIC RELATIONS WILL
        C                HAVE THE FOLLOWING APPROXIMATE ERRORS OVER OCEAN AREAS:
        C
        C                X    - 140 nT (North)
        C                Y    - 140 nT (East)
        C                Z    - 200 nT (Vertical) Positive is down
        C                H    - 200 nT (Horizontal)
        C
        C                OVER LAND THE MAXIMUM RMS ERRORS ARE EXPECTED TO BE
        C                HIGHER, ALTHOUGH THE RMS ERRORS FOR DEC, DIP, AND GV
        C                ARE STILL ESTIMATED TO BE LESS THAN 1.0 DEGREE, FOR
        C                THE ENTIRE 5-YEAR LIFE OF THE MODEL AT THE EARTH's
        C                SURFACE.  THE OTHER COMPONENT ERRORS OVER LAND ARE
        C                MORE DIFFICULT TO ESTIMATE AND SO ARE NOT GIVEN.
        C
        C                THE ACCURACY AT ANY GIVEN TIME FOR ALL OF THESE
        C                GEOMAGNETIC PARAMETERS DEPENDS ON THE GEOMAGNETIC
        C                LATITUDE.  THE ERRORS ARE LEAST FROM THE EQUATOR TO
        C                MID-LATITUDES AND GREATEST NEAR THE MAGNETIC POLES.
        C
        C                IT IS VERY IMPORTANT TO NOTE THAT A DEGREE AND
        C                ORDER 12 MODEL, SUCH AS WMM-2005, DESCRIBES ONLY
        C                THE LONG WAVELENGTH SPATIAL MAGNETIC FLUCTUATIONS
        C                DUE TO EARTH'S CORE.  NOT INCLUDED IN THE WMM SERIES
        C                MODELS ARE INTERMEDIATE AND SHORT WAVELENGTH
        C                SPATIAL FLUCTUATIONS OF THE GEOMAGNETIC FIELD
        C                WHICH ORIGINATE IN THE EARTH'S MANTLE AND CRUST.
        C                CONSEQUENTLY, ISOLATED ANGULAR ERRORS AT VARIOUS
        C                POSITIONS ON THE SURFACE (PRIMARILY OVER LAND, IN
        C                CONTINENTAL MARGINS AND OVER OCEANIC SEAMOUNTS,
        C                RIDGES AND TRENCHES) OF SEVERAL DEGREES MAY BE
        C                EXPECTED. ALSO NOT INCLUDED IN THE MODEL ARE
        C                NONSECULAR TEMPORAL FLUCTUATIONS OF THE GEOMAGNETIC
        C                FIELD OF MAGNETOSPHERIC AND IONOSPHERIC ORIGIN.
        C                DURING MAGNETIC STORMS, TEMPORAL FLUCTUATIONS CAN
        C                CAUSE SUBSTANTIAL DEVIATIONS OF THE GEOMAGNETIC
        C                FIELD FROM MODEL VALUES.  IN ARCTIC AND ANTARCTIC
        C                REGIONS, AS WELL AS IN EQUATORIAL REGIONS, DEVIATIONS
        C                FROM MODEL VALUES ARE BOTH FREQUENT AND PERSISTENT.
        C
        C                IF THE REQUIRED DECLINATION ACCURACY IS MORE
        C                STRINGENT THAN THE WMM SERIES OF MODELS PROVIDE, THEN
        C                THE USER IS ADVISED TO REQUEST SPECIAL (REGIONAL OR
        C                LOCAL) SURVEYS BE PERFORMED AND MODELS PREPARED.
        C                REQUESTS OF THIS NATURE SHOULD BE MADE TO NIMA
        C                AT THE ADDRESS ABOVE.
        C
        C***********************************************************************
        C
        C     USAGE:  THIS ROUTINE IS BROKEN UP INTO TWO PARTS:
        C
        C             A) AN INITIALIZATION MODULE, WHICH IS CALLED ONLY
        C                ONCE AT THE BEGINNING OF THE MAIN (CALLING)
        C                PROGRAM
        C             B) A PROCESSING MODULE, WHICH COMPUTES THE MAGNETIC
        C                FIELD PARAMETERS FOR EACH SPECIFIED GEODETIC
        C                POSITION (ALTITUDE, LATITUDE, LONGITUDE) AND TIME
        C
        C             INITIALIZATION IS MADE VIA A SINGLE CALL TO THE MAIN
        C             ENTRY POINT (GEOMAG), WHILE SUBSEQUENT PROCESSING
        C             CALLS ARE MADE THROUGH THE SECOND ENTRY POINT (GEOMG1).
        C             ONE CALL TO THE PROCESSING MODULE IS REQUIRED FOR EACH
        C             POSITION AND TIME.
        C
        C             THE VARIABLE MAXDEG IN THE INITIALIZATION CALL IS THE
        C             MAXIMUM DEGREE TO WHICH THE SPHERICAL HARMONIC MODEL
        C             IS TO BE COMPUTED.  IT MUST BE SPECIFIED BY THE USER
        C             IN THE CALLING ROUTINE.  NORMALLY IT IS 12 BUT IT MAY
        C             BE SET LESS THAN 12 TO INCREASE COMPUTATIONAL SPEED AT
        C             THE EXPENSE OF REDUCED ACCURACY.
        C
        C             THE PC VERSION OF THIS SUBROUTINE MUST BE COMPILED
        C             WITH A FORTRAN 77 COMPATIBLE COMPILER SUCH AS THE
        C             MICROSOFT OPTIMIZING FORTRAN COMPILER VERSION 4.1
        C             OR LATER.
        C
        C**********************************************************************
        C
        C     REFERENCES:
        C
        C       JOHN M. QUINN, DAVID J. KERRIDGE AND DAVID R. BARRACLOUGH,
        C            WORLD MAGNETIC CHARTS FOR 1985 - SPHERICAL HARMONIC
        C            MODELS OF THE GEOMAGNETIC FIELD AND ITS SECULAR
        C            VARIATION, GEOPHYS. J. R. ASTR. SOC. (1986) 87,
        C            PP 1143-1157
        C
        C       DEFENSE MAPPING AGENCY TECHNICAL REPORT, TR 8350.2:
        C            DEPARTMENT OF DEFENSE WORLD GEODETIC SYSTEM 1984,
        C            SEPT. 30 (1987)
        C
        C       JOHN M. QUINN, RACHEL J. COLEMAN, MICHAEL R. PECK, AND
        C            STEPHEN E. LAUBER; THE JOINT US/UK 1990 EPOCH
        C            WORLD MAGNETIC MODEL, TECHNICAL REPORT NO. 304,
        C            NAVAL OCEANOGRAPHIC OFFICE (1991)
        C
        C       JOHN M. QUINN, RACHEL J. COLEMAN, DONALD L. SHIEL, AND
        C            JOHN M. NIGRO; THE JOINT US/UK 1995 EPOCH WORLD
        C            MAGNETIC MODEL, TECHNICAL REPORT NO. 314, NAVAL
        C            OCEANOGRAPHIC OFFICE (1995)
        C
        C            SUSAN AMCMILLAN, DAVID R. BARRACLOUGH, JOHN M. QUINN, AND
        C            RACHEL J. COLEMAN;  THE 1995 REVISION OF THE JOINT US/UK
        C            GEOMAGNETIC FIELD MODELS - I. SECULAR VARIATION, JOURNAL OF
        C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 229-243
        C            (1997)
        C
        C            JOHN M. QUINN, RACHEL J. COELMAN, SUSAM MACMILLAN, AND
        C            DAVID R. BARRACLOUGH;  THE 1995 REVISION OF THE JOINT
        C            US/UK GEOMAGNETIC FIELD MODELS: II. MAIN FIELD,JOURNAL OF
        C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 245 - 261
        C            (1997)
        C
        C***********************************************************************
        C
        C     PARAMETER DESCRIPTIONS:
        C
        C       A      - SEMIMAJOR AXIS OF WGS-84 ELLIPSOID (KM)
        C       B      - SEMIMINOR AXIS OF WGS-84 ELLIPSOID (KM)
        C       RE     - MEAN RADIUS OF IAU-66 ELLIPSOID (KM)
        C       SNORM  - SCHMIDT NORMALIZATION FACTORS
        C       C      - GAUSS COEFFICIENTS OF MAIN GEOMAGNETIC MODEL (NT)
        C       CD     - GAUSS COEFFICIENTS OF SECULAR GEOMAGNETIC MODEL (NT/YR)
        C       TC     - TIME ADJUSTED GEOMAGNETIC GAUSS COEFFICIENTS (NT)
        C       OTIME  - TIME ON PREVIOUS CALL TO GEOMAG (YRS)
        C       OALT   - GEODETIC ALTITUDE ON PREVIOUS CALL TO GEOMAG (YRS)
        C       OLAT   - GEODETIC LATITUDE ON PREVIOUS CALL TO GEOMAG (DEG.)
        C       TIME   - COMPUTATION TIME (YRS)                        (INPUT)
        C                (EG. 1 JULY 1995 = 1995.500)
        C       ALT    - GEODETIC ALTITUDE (KM)                        (INPUT)
        C       GLAT   - GEODETIC LATITUDE (DEG.)                      (INPUT)
        C       GLON   - GEODETIC LONGITUDE (DEG.)                     (INPUT)
        C       EPOCH  - BASE TIME OF GEOMAGNETIC MODEL (YRS)
        C       DTR    - DEGREE TO RADIAN CONVERSION
        C       SP(M)  - SINE OF (M*SPHERICAL COORD. LONGITUDE)
        C       CP(M)  - COSINE OF (M*SPHERICAL COORD. LONGITUDE)
        C       ST     - SINE OF (SPHERICAL COORD. LATITUDE)
        C       CT     - COSINE OF (SPHERICAL COORD. LATITUDE)
        C       R      - SPHERICAL COORDINATE RADIAL POSITION (KM)
        C       CA     - COSINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
        C       SA     - SINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
        C       BR     - RADIAL COMPONENT OF GEOMAGNETIC FIELD (NT)
        C       BT     - THETA COMPONENT OF GEOMAGNETIC FIELD (NT)
        C       BP     - PHI COMPONENT OF GEOMAGNETIC FIELD (NT)
        C       P(N,M) - ASSOCIATED LEGENDRE POLYNOMIALS (UNNORMALIZED)
        C       PP(N)  - ASSOCIATED LEGENDRE POLYNOMIALS FOR M=1 (UNNORMALIZED)
        C       DP(N,M)- THETA DERIVATIVE OF P(N,M) (UNNORMALIZED)
        C       BX     - NORTH GEOMAGNETIC COMPONENT (NT)
        C       BY     - EAST GEOMAGNETIC COMPONENT (NT)
        C       BZ     - VERTICALLY DOWN GEOMAGNETIC COMPONENT (NT)
        C       BH     - HORIZONTAL GEOMAGNETIC COMPONENT (NT)
        C       DEC    - GEOMAGNETIC DECLINATION (DEG.)                (OUTPUT)
        C                  EAST=POSITIVE ANGLES
        C                  WEST=NEGATIVE ANGLES
        C       DIP    - GEOMAGNETIC INCLINATION (DEG.)                (OUTPUT)
        C                  DOWN=POSITIVE ANGLES
        C                    UP=NEGATIVE ANGLES
        C       TI     - GEOMAGNETIC TOTAL INTENSITY (NT)              (OUTPUT)
        C       GV     - GEOMAGNETIC GRID VARIATION (DEG.)             (OUTPUT)
        C                REFERENCED TO GRID NORTH
        C                GRID NORTH REFERENCED TO 0 MERIDIAN
        C                OF A POLAR STEREOGRAPHIC PROJECTION
        C                (ARCTIC/ANTARCTIC ONLY)
        C       MAXDEG - MAXIMUM DEGREE OF SPHERICAL HARMONIC MODEL    (INPUT)
        C       MOXORD - MAXIMUM ORDER OF SPHERICAL HARMONIC MODEL
        C
        C***********************************************************************
        C
        C     NOTE:  THIS VERSION OF GEOMAG USES A WMM SERIES GEOMAGNETIC
        C            FIELS MODEL REFERENCED TO THE WGS-84 GRAVITY MODEL
        C            ELLIPSOID
        C


        */


        var wmm = new WorldMagneticModel();
        this.setDecModule(wmm);
    },

    getDeclination: function(lat, lng) {
        var wmm = this.getDecModule();
        var wdt = new Date();
        var wmmDate = wdt.getFullYear() + ((wdt.getMonth() + 1)/12.0);
        var dec = wmm.declination(0.0, lat, lng, wmmDate);
        console.info('CoordsHelper - getDeclination - dec is:' + dec);
        return dec;

    },

    calcDistBearing: function(firstPoint, secondPoint) {
        Number.prototype.toRad = function() {
            return this * Math.PI / 180;
        };

        Number.prototype.toDeg = function() {
            return this * 180 / Math.PI;
        };


        var R = 6371; // km
        var dLat = (secondPoint.lat()-firstPoint.lat()).toRad();
        var dLon = (secondPoint.lng()-firstPoint.lng()).toRad();
        var lat1 = firstPoint.lat().toRad();
        var lat2 = secondPoint.lat().toRad();

        var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        var d = R * c * 1000;




        var y = Math.sin(dLon) * Math.cos(lat2);
        var x = Math.cos(lat1)*Math.sin(lat2) -
        Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
        var brng = Math.atan2(y, x).toDeg();



        return [d, brng];
    }

});
/*
 * File: app/model/walkPoint.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.model.walkPoint', {
    extend: 'Ext.data.Model',

    config: {
        fields: [
            {
                name: 'lng',
                type: 'float'
            },
            {
                name: 'lat',
                type: 'float'
            },
            {
                name: 'date',
                type: 'date'
            }
        ],
        proxy: {
            type: 'localstorage',
            id: 'walkPoint'
        }
    }
});
/**
 * @private
 *
 * This object handles communication between the WebView and Sencha's native shell.
 * Currently it has two primary responsibilities:
 *
 * 1. Maintaining unique string ids for callback functions, together with their scope objects
 * 2. Serializing given object data into HTTP GET request parameters
 *
 * As an example, to capture a photo from the device's camera, we use `Ext.device.Camera.capture()` like:
 *
 *     Ext.device.Camera.capture(
 *         function(dataUri){
 *             // Do something with the base64-encoded `dataUri` string
 *         },
 *         function(errorMessage) {
 *    
 *         },
 *         callbackScope,
 *         {
 *             quality: 75,
 *             width: 500,
 *             height: 500
 *         }
 *     );
 * 
 * Internally, `Ext.device.Communicator.send()` will then be invoked with the following argument:
 * 
 *     Ext.device.Communicator.send({
 *         command: 'Camera#capture',
 *         callbacks: {
 *             onSuccess: function() { ... },
 *             onError: function() { ... },
 *         },
 *         scope: callbackScope,
 *         quality: 75,
 *         width: 500,
 *         height: 500
 *     });
 * 
 * Which will then be transformed into a HTTP GET request, sent to native shell's local
 * HTTP server with the following parameters:
 * 
 *     ?quality=75&width=500&height=500&command=Camera%23capture&onSuccess=3&onError=5
 * 
 * Notice that `onSuccess` and `onError` have been converted into string ids (`3` and `5`
 * respectively) and maintained by `Ext.device.Communicator`.
 * 
 * Whenever the requested operation finishes, `Ext.device.Communicator.invoke()` simply needs
 * to be executed from the native shell with the corresponding ids given before. For example:
 * 
 *     Ext.device.Communicator.invoke('3', ['DATA_URI_OF_THE_CAPTURED_IMAGE_HERE']);
 * 
 * will invoke the original `onSuccess` callback under the given scope. (`callbackScope`), with
 * the first argument of 'DATA_URI_OF_THE_CAPTURED_IMAGE_HERE'
 * 
 * Note that `Ext.device.Communicator` maintains the uniqueness of each function callback and
 * its scope object. If subsequent calls to `Ext.device.Communicator.send()` have the same
 * callback references, the same old ids will simply be reused, which guarantee the best possible
 * performance for a large amount of repeative calls.
 */
Ext.define('Ext.device.communicator.Default', {

    SERVER_URL: 'http://localhost:3000', // Change this to the correct server URL

    callbackDataMap: {},

    callbackIdMap: {},

    idSeed: 0,

    globalScopeId: '0',

    generateId: function() {
        return String(++this.idSeed);
    },

    getId: function(object) {
        var id = object.$callbackId;

        if (!id) {
            object.$callbackId = id = this.generateId();
        }

        return id;
    },

    getCallbackId: function(callback, scope) {
        var idMap = this.callbackIdMap,
            dataMap = this.callbackDataMap,
            id, scopeId, callbackId, data;

        if (!scope) {
            scopeId = this.globalScopeId;
        }
        else if (scope.isIdentifiable) {
            scopeId = scope.getId();
        }
        else {
            scopeId = this.getId(scope);
        }

        callbackId = this.getId(callback);

        if (!idMap[scopeId]) {
            idMap[scopeId] = {};
        }

        if (!idMap[scopeId][callbackId]) {
            id = this.generateId();
            data = {
                callback: callback,
                scope: scope
            };

            idMap[scopeId][callbackId] = id;
            dataMap[id] = data;
        }

        return idMap[scopeId][callbackId];
    },

    getCallbackData: function(id) {
        return this.callbackDataMap[id];
    },

    invoke: function(id, args) {
        var data = this.getCallbackData(id);

        data.callback.apply(data.scope, args);
    },

    send: function(args) {
        var callbacks, scope, name, callback;

        if (!args) {
            args = {};
        }
        else if (args.callbacks) {
            callbacks = args.callbacks;
            scope = args.scope;

            delete args.callbacks;
            delete args.scope;

            for (name in callbacks) {
                if (callbacks.hasOwnProperty(name)) {
                    callback = callbacks[name];

                    if (typeof callback == 'function') {
                        args[name] = this.getCallbackId(callback, scope);
                    }
                }
            }
        }

        this.doSend(args);
    },

    doSend: function(args) {
        var xhr = new XMLHttpRequest();

        xhr.open('GET', this.SERVER_URL + '?' + Ext.Object.toQueryString(args), false);
        xhr.send(null);
    }
});


/**
 * @private
 */
Ext.define('Ext.device.communicator.Android', {
    extend: 'Ext.device.communicator.Default',

    doSend: function(args) {
        window.Sencha.action(JSON.stringify(args));
    }
});

/**
 * @private
 */
Ext.define('Ext.device.orientation.Abstract', {
    extend: 'Ext.EventedBase',

    /**
     * @event orientationchange
     * Fires when the orientation has been changed on this device.
     *
     *     Ext.device.Orientation.on({
     *         scope: this,
     *         orientationchange: function(e) {
     *             console.log('Alpha: ', e.alpha);
     *             console.log('Beta: ', e.beta);
     *             console.log('Gamma: ', e.gamma);
     *         }
     *     });
     *
     * @param {Object} event The event object
     * @param {Object} event.alpha The alpha value of the orientation event
     * @param {Object} event.beta The beta value of the orientation event
     * @param {Object} event.gamma The gamma value of the orientation event
     */

    onDeviceOrientation: function(e) {
        this.doFireEvent('orientationchange', [e]);
    }
});

/**
 * @private
 */
Ext.define('Ext.device.geolocation.Abstract', {
    config: {
        /**
         * @cfg {Number} maximumAge
         * This option indicates that the application is willing to accept cached location information whose age
         * is no greater than the specified time in milliseconds. If maximumAge is set to 0, an attempt to retrieve
         * new location information is made immediately.
         */
        maximumAge: 0,

        /**
         * @cfg {Number} frequency The default frequency to get the current position when using {@link Ext.device.Geolocation#watchPosition}.
         */
        frequency: 10000,

        /**
         * @cfg {Boolean} allowHighAccuracy True to allow high accuracy when getting the current position.
         */
        allowHighAccuracy: false,

        /**
         * @cfg {Number} timeout
         * The maximum number of milliseconds allowed to elapse between a location update operation.
         */
        timeout: Infinity
    },

    /**
     * Attempts to get the current position of this device.
     *
     *     Ext.device.Geolocation.getCurrentPosition({
     *         success: function(position) {
     *             console.log(position);
     *         },
     *         failure: function() {
     *             Ext.Msg.alert('Geolocation', 'Something went wrong!');
     *         }
     *     });
     *
     * *Note:* If you want to watch the current position, you could use {@link Ext.device.Geolocation#watchPosition} instead.
     *
     * @param {Object} config An object which contains the following config options:
     *
     * @param {Function} config.success
     * The function to call when the location of the current device has been received.
     *
     * @param {Object} config.success.position
     *
     * @param {Function} config.failure
     * The function that is called when something goes wrong.
     *
     * @param {Object} config.scope
     * The scope of the `success` and `failure` functions.
     *
     * @param {Number} config.maximumAge
     * The maximum age of a cached location. If you do not enter a value for this, the value of {@link #maximumAge}
     * will be used.
     *
     * @param {Number} config.timeout
     * The timeout for this request. If you do not specify a value, it will default to {@link #timeout}.
     *
     * @param {Boolean} config.allowHighAccuracy
     * True to enable allow accuracy detection of the location of the current device. If you do not specify a value, it will
     * default to {@link #allowHighAccuracy}.
     */
    getCurrentPosition: function(config) {
        var defaultConfig = Ext.device.geolocation.Abstract.prototype.config;

        config = Ext.applyIf(config, {
            maximumAge: defaultConfig.maximumAge,
            frequency: defaultConfig.frequency,
            allowHighAccuracy: defaultConfig.allowHighAccuracy,
            timeout: defaultConfig.timeout
        });


        return config;
    },

    /**
     * Watches for the current position and calls the callback when successful depending on the specified {@link #frequency}.
     *
     *     Ext.device.Geolocation.watchPosition({
     *         callback: function(position) {
     *             console.log(position);
     *         },
     *         failure: function() {
     *             Ext.Msg.alert('Geolocation', 'Something went wrong!');
     *         }
     *     });
     *
     * @param {Object} config An object which contains the following config options:
     *
     * @param {Function} config.callback
     * The function to be called when the position has been updated.
     *
     * @param {Function} config.failure
     * The function that is called when something goes wrong.
     *
     * @param {Object} config.scope
     * The scope of the `success` and `failure` functions.
     *
     * @param {Boolean} config.frequency
     * The frequency in which to call the supplied callback. Defaults to {@link #frequency} if you do not specify a value.
     *
     * @param {Boolean} config.allowHighAccuracy
     * True to enable allow accuracy detection of the location of the current device. If you do not specify a value, it will
     * default to {@link #allowHighAccuracy}.
     */
    watchPosition: function(config) {
        var defaultConfig = Ext.device.geolocation.Abstract.prototype.config;

        config = Ext.applyIf(config, {
            maximumAge: defaultConfig.maximumAge,
            frequency: defaultConfig.frequency,
            allowHighAccuracy: defaultConfig.allowHighAccuracy,
            timeout: defaultConfig.timeout
        });


        return config;
    },

    /**
     * If you are currently watching for the current position, this will stop that task.
     */
    clearWatch: function() {}
});

/*
 * File: app/store/WalkPointData.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.store.WalkPointData', {
    extend: 'Ext.data.Store',

    requires: [
        'RetModel.model.walkPoint'
    ],

    config: {
        autoLoad: true,
        autoSync: true,
        clearOnPageLoad: false,
        model: 'RetModel.model.walkPoint',
        storeId: 'WalkPointStore'
    }
});
/**
 * @private
 */
Ext.define('Ext.device.Communicator', {
    requires: [
        'Ext.device.communicator.Default',
        'Ext.device.communicator.Android'
    ],

    singleton: true,

    constructor: function() {
        if (Ext.os.is.Android) {
            return new Ext.device.communicator.Android();
        }

        return new Ext.device.communicator.Default();
    }
});

/**
 * Provides the HTML5 implementation for the orientation API.
 * @private
 */
Ext.define('Ext.device.orientation.HTML5', {
    extend: 'Ext.device.orientation.Abstract',

    initialize: function() {
        this.onDeviceOrientation = Ext.Function.bind(this.onDeviceOrientation, this);
        window.addEventListener('deviceorientation', this.onDeviceOrientation, true);
    }
});

/**
 * @private
 */
Ext.define('Ext.device.orientation.Sencha', {
    extend: 'Ext.device.orientation.Abstract',

    requires: [
        'Ext.device.Communicator'
    ],

    /**
     * From the native shell, the callback needs to be invoked infinitely using a timer, ideally 50 times per second.
     * The callback expects one event object argument, the format of which should looks like this:
     *
     *     {
     *          alpha: 0,
     *          beta: 0,
     *          gamma: 0
     *     }
     *
     * Refer to [Safari DeviceOrientationEvent Class Reference][1] for more details.
     * 
     * [1]: http://developer.apple.com/library/safari/#documentation/SafariDOMAdditions/Reference/DeviceOrientationEventClassRef/DeviceOrientationEvent/DeviceOrientationEvent.html
     */
    initialize: function() {
        Ext.device.Communicator.send({
            command: 'Orientation#watch',
            callbacks: {
                callback: this.onDeviceOrientation
            },
            scope: this
        });
    }
});

/**
 * This class provides you with a cross platform way of listening to when the the orientation changes on the
 * device your application is running on.
 *
 * The {@link Ext.device.Orientation#orientationchange orientationchange} event gets passes the `alpha`, `beta` and
 * `gamma` values.
 *
 * You can find more information about these values and how to use them on the [W3C device orientation specification](http://dev.w3.org/geo/api/spec-source-orientation.html#deviceorientation).
 *
 * ## Example
 *
 * To listen to the device orientation, you can do the following:
 *
*     Ext.device.Orientation.on({
*         scope: this,
*         orientationchange: function(e) {
*             console.log('Alpha: ', e.alpha);
*             console.log('Beta: ', e.beta);
*             console.log('Gamma: ', e.gamma);
*         }
*     });
 *
 * @mixins Ext.device.orientation.Abstract
 * 
 * @aside guide native_apis
 */
Ext.define('Ext.device.Orientation', {
    singleton: true,

    requires: [
        'Ext.device.Communicator',
        'Ext.device.orientation.HTML5',
        'Ext.device.orientation.Sencha'
    ],

    constructor: function() {
        var browserEnv = Ext.browser.is;

        if (browserEnv.Sencha) {
            return Ext.create('Ext.device.orientation.Sencha');
        }
        else {
            return Ext.create('Ext.device.orientation.HTML5');
        }
    }
});

/**
 * @private
 */
Ext.define('Ext.device.geolocation.Sencha', {
    extend: 'Ext.device.geolocation.Abstract',

    getCurrentPosition: function(config) {
        config = this.callParent([config]);

        Ext.apply(config, {
            command: 'Geolocation#getCurrentPosition',
            callbacks: {
                success: config.success,
                failure: config.failure
            }
        });

        Ext.applyIf(config, {
            scope: this
        });

        delete config.success;
        delete config.failure;

        Ext.device.Communicator.send(config);

        return config;
    },

    watchPosition: function(config) {
        config = this.callParent([config]);

        Ext.apply(config, {
            command: 'Geolocation#watchPosition',
            callbacks: {
                success: config.callback,
                failure: config.failure
            }
        });

        Ext.applyIf(config, {
            scope: this
        });

        delete config.callback;
        delete config.failure;

        Ext.device.Communicator.send(config);

        return config;
    },

    clearWatch: function() {
        Ext.device.Communicator.send({
            command: 'Geolocation#clearWatch'
        });
    }
});

/**
 * @private
 */
Ext.define('Ext.device.geolocation.Simulator', {
    extend: 'Ext.device.geolocation.Abstract',
    requires: ['Ext.util.Geolocation'],

    getCurrentPosition: function(config) {
        config = this.callParent([config]);

        Ext.apply(config, {
            autoUpdate: false,
            listeners: {
                scope: this,
                locationupdate: function(geolocation) {
                    if (config.success) {
                        config.success.call(config.scope || this, geolocation.position);
                    }
                },
                locationerror: function() {
                    if (config.failure) {
                        config.failure.call(config.scope || this);
                    }
                }
            }
        });

        this.geolocation = Ext.create('Ext.util.Geolocation', config);
        this.geolocation.updateLocation();

        return config;
    },

    watchPosition: function(config) {
        config = this.callParent([config]);

        Ext.apply(config, {
            listeners: {
                scope: this,
                locationupdate: function(geolocation) {
                    if (config.callback) {
                        config.callback.call(config.scope || this, geolocation.position);
                    }
                },
                locationerror: function() {
                    if (config.failure) {
                        config.failure.call(config.scope || this);
                    }
                }
            }
        });

        this.geolocation = Ext.create('Ext.util.Geolocation', config);

        return config;
    },

    clearWatch: function() {
        if (this.geolocation) {
            this.geolocation.destroy();
        }

        this.geolocation = null;
    }
});

/**
 * Provides access to the native Geolocation API when running on a device. There are three implementations of this API:
 *
 * - Sencha Packager
 * - [PhoneGap](http://docs.phonegap.com/en/1.4.1/phonegap_device_device.md.html)
 * - Browser
 *
 * This class will automatically select the correct implementation depending on the device your application is running on.
 *
 * ## Examples
 *
 * Getting the current location:
 *
 *     Ext.device.Geolocation.getCurrentPosition({
 *         success: function(position) {
 *             console.log(position.coords);
 *         },
 *         failure: function() {
 *             console.log('something went wrong!');
 *         }
 *     });
 *
 * Watching the current location:
 *
 *     Ext.device.Geolocation.watchPosition({
 *         frequency: 3000, // Update every 3 seconds
 *         callback: function(position) {
 *             console.log('Position updated!', position.coords);
 *         },
 *         failure: function() {
 *             console.log('something went wrong!');
 *         }
 *     });
 *
 * @mixins Ext.device.geolocation.Abstract
 *
 * @aside guide native_apis
 */
Ext.define('Ext.device.Geolocation', {
    singleton: true,

    requires: [
        'Ext.device.Communicator',
        // 'Ext.device.geolocation.PhoneGap',
        'Ext.device.geolocation.Sencha',
        'Ext.device.geolocation.Simulator'
    ],

    constructor: function() {
        var browserEnv = Ext.browser.is;

        if (browserEnv.WebView) {
            if (browserEnv.PhoneGap) {
                return Ext.create('Ext.device.geolocation.PhoneGap');
            }
            else {
                return Ext.create('Ext.device.geolocation.Sencha');
            }
        }
        else {
            return Ext.create('Ext.device.geolocation.Simulator');
        }
    }
});

/*
 * File: app/controller/DevicesMonitor.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.controller.DevicesMonitor', {
    extend: 'Ext.app.Controller',

    requires: [
        'Ext.device.Geolocation',
        'Ext.device.Orientation'
    ],

    config: {
    },

    launch: function() {
        console.log('DevicesMonitor was launched!');
        this.monitorGps();
        this.monitorCompass();

    },

    monitorGps: function() {
        console.info('DevicesMonitor - monitorGps was called!');

        var gpsStore = Ext.getStore('GpsDataStore');
        gpsStore.load();
        var gpsStoreSize = gpsStore.getCount();
        var gpsCurrPos = gpsStore.first();
        console.log('gps store size:' + gpsStoreSize);
        if (gpsStoreSize === 0) {
            console.info('gps store size is 0. initializing 1 value.');
            gpsCurrPos = Ext.create('RetModel.model.gpsData', {
                x: 0,
                y: 0,
                date: new Date()
            }
            );
            gpsCurrPos.save();
        }


        var xVal = 0;
        var yVal = 0;
        var locUpdateCount = 0;
        var date = 0;

        var mapHandlerController = this.getApplication().getController('MapHandler');
        var devicesFormsUpdaterController = this.getApplication().getController('DevicesFormsUpdater');


        monitorGpsGeo();


        function monitorGpsGeo() {
            var geo = Ext.create('Ext.util.Geolocation', {
                autoUpdate: true,
                frequency: 2500,
                maximumAge:0,
                allowHighAccuracy: true,  

                listeners: {
                    locationupdate: function(geo) {
                        //console.log('DeviceMonitor - monitorGps - locationupdate (' + locUpdateCount + ') geo:');
                        //console.log(geo);

                        xVal = geo.getLongitude();
                        yVal = geo.getLatitude();
                        //xVal = geo.getLongitude() + (0.002 * locUpdateCount);
                        //yVal = geo.getLatitude() + (0.0005 * locUpdateCount * locUpdateCount);
                        date = new Date(geo.getTimestamp());
                        gpsCurrPos.set('x',xVal);
                        gpsCurrPos.set('y',yVal);
                        gpsCurrPos.set('date',date);
                        gpsCurrPos.save();
                        mapHandlerController.updateCurrPosMarker(yVal, xVal);
                        devicesFormsUpdaterController.updateGps(gpsCurrPos);
                        locUpdateCount = locUpdateCount + 1;
                    },
                    locationerror: function(geo, bTimeout, bPermissionDenied, bLocationUnavailable, message) {
                        if(bLocationUnavailable){
                            Ext.Msg.alert('Geolocation','Location services aren\'t supported! ' + message);
                        } else if (bPermissionDenied){
                            Ext.Msg.alert('Geolocation','Location services aren\'t authorized. Change device settings! ' + message);
                        } else if(bTimeout){
                            Ext.Msg.alert('Timeout occurred. ' + message);
                        } else {
                            Ext.Msg.alert('Error occurred. ' + message);
                        }
                    }
                }
            });
        }







        function monitorGpsHtml5() {


            function initGeolocation()
            {
                if(navigator.geolocation) {

                    // Call getCurrentPosition with success and failure callbacks
                    navigator.geolocation.getCurrentPosition( success, fail, {maximumAge: 1000, enableHighAccuracy:true, timeout:20000} );
                }
                else {
                    alert("Sorry, your browser does not support geolocation services.");
                }
            }

            function success(position) {
                // Define the coordinates as a Google Maps LatLng Object
                //var coords = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);

                console.log('DeviceMonitor - monitorGpsHtml5 - locationupdate (' + locUpdateCount + ') position:');
                console.log(position);

                xVal = position.coords.longitude;
                yVal = position.coords.latitude;
                date = new Date(position.timestamp);
                gpsCurrPos.set('x',xVal);
                gpsCurrPos.set('y',yVal);
                gpsCurrPos.set('date',date);
                gpsCurrPos.save();
                mapHandlerController.updateCurrPosMarker(yVal, xVal);
                devicesFormsUpdaterController.updateGps(gpsCurrPos);
                console.log('locationupdate (' + locUpdateCount + ') - gpsRec3 was set. xVal:' + xVal + ', yVal:' + yVal + ', Date:' + date);
                locUpdateCount = locUpdateCount + 1;


                setTimeout(initGeolocation,3000);

            }

            function fail(error) {
                switch(error.code) {
                    case error.TIMEOUT:
                    alert ('Timeout');
                    break;
                    case error.POSITION_UNAVAILABLE:
                    alert ('Position unavailable');
                    break;
                    case error.PERMISSION_DENIED:
                    alert ('Permission denied');
                    break;
                    case error.UNKNOWN_ERROR:
                    alert ('Unknown error');
                    break;
                }
                setTimeout(initGeolocation,3000);
            }

            initGeolocation();
        }


        function monitorGpsDevice() {
            var watchID = Ext.device.Geolocation.watchPosition({
                frequency: 10000,
                allowHighAccuracy: true,  

                callback: function(position) {
                    console.log('DeviceMonitor - monitorGps - locationupdate (' + locUpdateCount + ') position:');
                    console.log(position);

                    xVal = position.coords.longitude;
                    yVal = position.coords.latitude;
                    date = new Date(position.timestamp);
                    gpsCurrPos.set('x',xVal);
                    gpsCurrPos.set('y',yVal);
                    gpsCurrPos.set('date',date);
                    gpsCurrPos.save();
                    mapHandlerController.updateCurrPosMarker(yVal, xVal);
                    devicesFormsUpdaterController.updateGps(gpsCurrPos);
                    console.log('locationupdate (' + locUpdateCount + ') - gpsRec3 was set. xVal:' + xVal + ', yVal:' + yVal + ', Date:' + date);
                    locUpdateCount = locUpdateCount + 1;
                },
                failure: function(e) {
                    console.log('watchPosition - something went wrong!');
                    console.log(e);
                }

            });
        }


        //testInterval();

        function testInterval() {

            console.log('DeviceMonitor - testInterval - locationupdate (' + locUpdateCount + ')');

            xVal = 15;
            yVal = 19;
            date = new Date();
            gpsCurrPos.set('x',xVal);
            gpsCurrPos.set('y',yVal);
            gpsCurrPos.set('date',date);
            gpsCurrPos.save();
            mapHandlerController.updateCurrPosMarker(yVal, xVal);
            devicesFormsUpdaterController.updateGps(gpsCurrPos);
            console.log('locationupdate (' + locUpdateCount + ') - gpsRec3 was set. xVal:' + xVal + ', yVal:' + yVal + ', Date:' + date);
            locUpdateCount = locUpdateCount + 1;


            setTimeout(testInterval,3000);
        } 

    },

    monitorCompass: function() {
        console.info('DevicesMonitor - monitorCompass was called!');

        var compassStore = Ext.getStore('CompassDataStore');
        compassStore.load();
        var compassStoreSize = compassStore.getCount();
        var compassCurrVal = compassStore.first();
        console.log('DevicesMonitor - monitorCompass compass store size:' + compassStoreSize);
        if (compassStoreSize === 0) {
            console.info('DevicesMonitor - monitorCompass compass store size is 0. initializing 1 value.');
            compassCurrVal = Ext.create('RetModel.model.compassData', {
                bearing: 0,
                date: new Date()
            }
            );
            compassCurrVal.save();
        }



        var compassUpdateCount = 0;

        var mapHandlerController = this.getApplication().getController('MapHandler');
        var devicesFormsUpdaterController = this.getApplication().getController('DevicesFormsUpdater');


        monitorWithInterval();

        //monitorCompassHtml();
        //monitorDeviceBuffered();
        //monitorDevice();

        function monitorCompassHtml() {

            window.setTimeout(function () {
                if ('ondeviceorientation' in window) {

                    window.addEventListener('deviceorientation', function(e) {
                        var direction;

                        if (typeof e.webkitCompassHeading !== 'undefined') {
                            direction = e.webkitCompassHeading;

                            if (typeof window.orientation !== 'undefined') {
                                direction += window.orientation;
                            }
                        } else {
                            // http://dev.w3.org/geo/api/spec-source-orientation.html#deviceorientation
                            direction = 360 - e.alpha;
                        }

                        compassCurrVal.set('bearing',direction);
                        compassCurrVal.set('date',new Date());
                        compassCurrVal.save();
                        //mapHandlerController.updateCurrPosMarker(yVal, xVal);
                        devicesFormsUpdaterController.updateCompass(compassCurrVal);
                        console.log('DevicesMonitor - monitorCompass - compassUpdate (' + compassUpdateCount + ') - compassCurrVal was set. bearing:' + direction);
                        compassUpdateCount = compassUpdateCount + 1;

                    });
                    /*
                    window.setInterval(function() {
                    var angle = -dir;
                    document.getElementById('compass').style.webkitTransform = 'rotate(' + angle + 'deg)';
                    }, 100);
                    */
                } else {
                    Ext.Msg.alert('Sorry!', 'The browser does not support Device Orientation API.');
                }
            }, 200);
        }

        function monitorDevice() {
            Ext.device.Orientation.on({
                scope: this,
                buffer: 10,
                orientationchange: function(e) {
                    compassCurrVal.set('bearing',e.alpha);
                    compassCurrVal.set('date',new Date());
                    compassCurrVal.save();
                    //mapHandlerController.updateCurrPosMarker(yVal, xVal);
                    devicesFormsUpdaterController.updateCompass(compassCurrVal);
                    console.log('DevicesMonitor - monitorCompass - compassUpdate (' + compassUpdateCount + ') - compassCurrVal was set. bearing:' + e.alpha);
                    compassUpdateCount = compassUpdateCount + 1;
                }
            });
        }


        function monitorDeviceBuffered() {
            Ext.device.Orientation.on('orientationchange',
            function(e) {


                //compassCurrVal.set('bearing',e);
                compassCurrVal.set('bearing',e.alpha);
                //compassCurrVal.set('bearing',compassUpdateCount);

                compassCurrVal.set('date',new Date());
                compassCurrVal.save();
                //mapHandlerController.updateCurrPosMarker(yVal, xVal);
                devicesFormsUpdaterController.updateCompass(compassCurrVal);
                console.log('DevicesMonitor - monitorCompass - compassUpdate (' + compassUpdateCount + ') - compassCurrVal was set. bearing:' + e.alpha);
                compassUpdateCount = compassUpdateCount + 1;
            }, 
            this, {buffer: 30} );
        }


        function monitorWithInterval() {

            console.log('DeviceMonitor - monitorCompass - testInterval - called. time:' + compassUpdateCount);

            //devicesFormsUpdaterController.updateBearingCompass(80);
            //devicesFormsUpdaterController.updateCompass(80);

            Ext.device.Orientation.on('orientationchange',
            function(e) {

                var direction;

                if (typeof e.webkitCompassHeading !== 'undefined') {
                    direction = e.webkitCompassHeading;

                    if (typeof window.orientation !== 'undefined') {
                        direction += window.orientation;
                    }
                } else {
                    // http://dev.w3.org/geo/api/spec-source-orientation.html#deviceorientation
                    direction = 360 - e.alpha;
                }

                compassCurrVal.set('bearing',direction);
                compassCurrVal.set('date',new Date());
                compassCurrVal.save();
                mapHandlerController.updateCurrPosHeading(direction);
                devicesFormsUpdaterController.updateCompass(compassCurrVal);
                devicesFormsUpdaterController.updateBearingCompass(direction);
                console.log('DevicesMonitor - monitorCompass - compassUpdate (' + compassUpdateCount + ') - compassCurrVal was set. bearing:' + direction);
                compassUpdateCount = compassUpdateCount + 1;
                setTimeout(monitorWithInterval,500);

            }, 
            this, {single: true} );

        } 
    }

});
/*
 * File: app/view/main.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RetModel.view.main', {
    extend: 'Ext.Container',

    config: {
        id: 'mainView',
        itemId: 'mainView',
        layout: {
            animation: 'fade',
            type: 'card'
        },
        items: [
            {
                xtype: 'container',
                id: 'mapContainer',
                ui: '',
                items: [
                    {
                        xtype: 'map',
                        centered: true,
                        height: '100%',
                        id: 'googleMap',
                        itemId: 'googleMap',
                        width: '100%',
                        zIndex: 2,
                        mapOptions: 'center: new google.maps.LatLng(39.958636,-75.20496),\r\n// lost hills: 35.6669 , -119.78055\r\n// Tzeelim: 31.291681,34.574133\r\nzoom: 10,\r\nmapTypeId: google.maps.MapTypeId.TERRAIN\r\n\r\nmapTypeControlOptions: new google.maps.MapTypeControlOptions({google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.SATELLITE},\r\n                                                              google.maps.ControlPosition.TOP_RIGHT, DROPDOWN_MENU)'
                    },
                    {
                        xtype: 'image',
                        bottom: 40,
                        height: 32,
                        itemId: 'myimage',
                        right: 0,
                        ui: 'light',
                        width: 32,
                        zIndex: 9,
                        src: 'data/Settings_32.png'
                    },
                    {
                        xtype: 'image',
                        bottom: 140,
                        height: 32,
                        id: 'useLocation',
                        itemId: 'useLocation',
                        ui: 'light',
                        width: 32,
                        zIndex: 9,
                        src: './data/useCurrentOn.png'
                    },
                    {
                        xtype: 'actionsheet',
                        height: 260,
                        hidden: true,
                        id: 'options',
                        itemId: 'options',
                        ui: '',
                        hideOnMaskTap: true,
                        layout: {
                            type: 'default'
                        },
                        scrollable: false,
                        items: [
                            {
                                xtype: 'button',
                                bottom: 120,
                                cls: 'menubtnicon',
                                height: 60,
                                id: 'drawBearingBut',
                                itemId: 'drawBearingBut',
                                left: 0,
                                padding: 5,
                                styleHtmlContent: true,
                                width: 160,
                                zIndex: 6,
                                icon: './data/drawbearing.png',
                                iconAlign: 'right',
                                iconCls: 'menubtnicon',
                                iconMask: true
                            },
                            {
                                xtype: 'button',
                                bottom: 60,
                                cls: 'menubtnicon',
                                height: 60,
                                id: 'clearBearingBtn',
                                itemId: 'clearBearingBtn',
                                left: 0,
                                padding: 5,
                                styleHtmlContent: true,
                                width: 160,
                                zIndex: 6,
                                icon: './data/cleanBearing.png',
                                iconAlign: 'right',
                                iconCls: 'menubtnicon',
                                iconMask: true
                            },
                            {
                                xtype: 'button',
                                bottom: 60,
                                cls: 'menubtnicon',
                                height: 60,
                                id: 'clearPathBtn',
                                itemId: 'clearPathBtn',
                                left: 160,
                                padding: 5,
                                styleHtmlContent: true,
                                width: 160,
                                zIndex: 6,
                                icon: './data/cleanPath.png',
                                iconAlign: 'right',
                                iconCls: 'menubtnicon',
                                iconMask: true
                            },
                            {
                                xtype: 'button',
                                bottom: 180,
                                height: 60,
                                id: 'butGps',
                                itemId: 'butGps',
                                left: 160,
                                styleHtmlContent: true,
                                width: 160,
                                zIndex: 6,
                                icon: './data/Settings_32.png',
                                iconAlign: 'center',
                                text: 'gps'
                            },
                            {
                                xtype: 'button',
                                bottom: 180,
                                height: 60,
                                id: 'compGps',
                                itemId: 'compBut',
                                left: 0,
                                styleHtmlContent: true,
                                width: 160,
                                zIndex: 6,
                                icon: './data/Settings_32.png',
                                iconAlign: 'center',
                                text: 'compass'
                            },
                            {
                                xtype: 'button',
                                bottom: 0,
                                docked: 'bottom',
                                id: 'backOpt',
                                itemId: 'backOpt',
                                ui: 'back',
                                width: 70,
                                text: 'back'
                            }
                        ]
                    }
                ]
            },
            {
                xtype: 'formpanel',
                id: 'gpsData',
                itemId: 'gpsData',
                items: [
                    {
                        xtype: 'toolbar',
                        docked: 'top',
                        title: 'gps data',
                        items: [
                            {
                                xtype: 'button',
                                itemId: 'rawBack',
                                ui: 'back',
                                text: 'back'
                            }
                        ]
                    },
                    {
                        xtype: 'textfield',
                        itemId: 'x',
                        label: 'gps x',
                        name: 'x',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        itemId: 'y',
                        label: 'gps y',
                        name: 'y',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        height: 42,
                        itemId: 'date',
                        label: 'taken',
                        name: 'date',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        itemId: '',
                        label: 'form upd',
                        name: 'formUpdated',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        itemId: '',
                        label: 'num',
                        name: 'num',
                        value: 0,
                        readOnly: true
                    }
                ]
            },
            {
                xtype: 'formpanel',
                id: 'compassData',
                itemId: 'compassData',
                items: [
                    {
                        xtype: 'toolbar',
                        docked: 'top',
                        title: 'compass data',
                        items: [
                            {
                                xtype: 'button',
                                itemId: 'rawBack',
                                ui: 'back',
                                text: 'back'
                            }
                        ]
                    },
                    {
                        xtype: 'textfield',
                        itemId: 'bearing',
                        label: 'bearing',
                        name: 'bearing',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        label: 'fixed+',
                        name: 'fixedPos',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        label: 'fixed-',
                        name: 'fixedNeg',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        itemId: 'date',
                        label: 'date',
                        name: 'date',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        label: 'form upd',
                        name: 'formUpdated',
                        readOnly: true
                    },
                    {
                        xtype: 'textfield',
                        label: 'num',
                        name: 'num',
                        value: 0,
                        readOnly: true
                    }
                ]
            },
            {
                xtype: 'formpanel',
                id: 'newBearingLine',
                itemId: 'newBearingLine',
                items: [
                    {
                        xtype: 'toolbar',
                        docked: 'top',
                        id: 'NewBearingLineTitle',
                        title: 'New Bearing Line',
                        items: [
                            {
                                xtype: 'button',
                                itemId: 'rawBack',
                                ui: 'back',
                                text: 'back'
                            }
                        ]
                    },
                    {
                        xtype: 'numberfield',
                        id: 'bearing',
                        itemId: 'bearing',
                        label: 'Bearing',
                        name: 'bearing',
                        value: 0,
                        maxLength: 7,
                        placeHolder: '',
                        readOnly: false,
                        maxValue: 360,
                        minValue: 0
                    },
                    {
                        xtype: 'togglefield',
                        itemId: 'useCompass',
                        label: 'Use compass',
                        labelWidth: '50%',
                        name: 'useCompass'
                    },
                    {
                        xtype: 'numberfield',
                        itemId: 'distance',
                        label: 'Distance',
                        name: 'distance',
                        value: 1500,
                        maxLength: 9,
                        readOnly: false,
                        maxValue: 100000,
                        minValue: 0
                    },
                    {
                        xtype: 'textfield',
                        itemId: 'title',
                        label: 'Line title',
                        name: 'title',
                        value: 'Model # Flight #',
                        placeHolder: 'Enter title',
                        readOnly: false
                    },
                    {
                        xtype: 'button',
                        id: 'drawLineBtn',
                        itemId: 'drawLineBtn',
                        left: 90,
                        ui: 'confirm-round',
                        width: 131,
                        text: 'Draw line'
                    }
                ]
            }
        ],
        listeners: [
            {
                fn: 'onMyimageTap',
                event: 'tap',
                delegate: '#myimage'
            },
            {
                fn: 'onDrawBearingButTap',
                event: 'tap',
                delegate: '#drawBearingBut'
            },
            {
                fn: 'onDrawBearingButTap1',
                event: 'tap',
                delegate: '#clearBearingBtn'
            },
            {
                fn: 'onDrawBearingButTap11',
                event: 'tap',
                delegate: '#clearPathBtn'
            },
            {
                fn: 'onGpsButTap',
                event: 'tap',
                delegate: '#butGps'
            },
            {
                fn: 'onCompButTap',
                event: 'tap',
                delegate: '#compGps'
            },
            {
                fn: 'onBackOptTap',
                event: 'tap',
                delegate: '#backOpt'
            },
            {
                fn: 'onRawBackTap',
                event: 'tap',
                delegate: '#rawBack'
            },
            {
                fn: 'onRawBackTap1',
                event: 'tap',
                delegate: '#rawBack'
            },
            {
                fn: 'onRawBackTap11',
                event: 'tap',
                delegate: '#rawBack'
            },
            {
                fn: 'onNewBearingLineShow',
                event: 'show',
                delegate: '#newBearingLine'
            }
        ]
    },

    onMyimageTap: function(img, e, options) {
        this.down('#options').show();
    },

    onDrawBearingButTap: function(button, e, options) {
        this.down('#options').hide();
        this.setActiveItem(3);
    },

    onDrawBearingButTap1: function(button, e, options) {
        this.down('#options').hide();

    },

    onDrawBearingButTap11: function(button, e, options) {
        this.down('#options').hide();

    },

    onGpsButTap: function(button, e, options) {
        this.down('#options').hide();
        this.setActiveItem(1);
    },

    onCompButTap: function(button, e, options) {
        this.down('#options').hide();
        this.setActiveItem(2);
    },

    onBackOptTap: function(button, e, options) {
        this.down('#options').hide();
    },

    onRawBackTap: function(button, e, options) {
        this.setActiveItem(0);
    },

    onRawBackTap1: function(button, e, options) {
        this.setActiveItem(0);
    },

    onRawBackTap11: function(button, e, options) {
        this.setActiveItem(0);
    },

    onNewBearingLineShow: function(component, options) {
        component.down('field[name=bearing]').focus();
        console.log('new bearing line- called focus');

    }

});
/*
 * File: app.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.Loader.setConfig({
    enabled: true
});

Ext.application({
    models: [
        'compassData',
        'gpsData',
        'conf',
        'landingLine',
        'poi'
    ],
    stores: [
        'GpsData',
        'CompassData',
        'Conf',
        'LandingLineData',
        'poiData',
        'WalkPointData'
    ],
    icon: 'data/airplane.png',
    name: 'RetModel',
    startupImage: 'data/airplane.png',
    controllers: [
        'DevicesMonitor',
        'DevicesFormsUpdater',
        'MapHandler',
        'CoordsHelpers',
        'Conf',
        'DrawBearingLine',
        'MapCleaner'
    ],

    launch: function() {

        Ext.create('RetModel.view.main', {fullscreen: true});
    }

});

